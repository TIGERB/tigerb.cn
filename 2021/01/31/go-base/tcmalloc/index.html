<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="Trying to be the person you want to be.">
    

    <!--Author-->
    
        <meta name="author" content="施展">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="18张图解密新时代内存分配器TCMalloc"/>
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="施展TIGERB"/>

    <!--Page Cover-->
    
        <meta property="og:image" content=""/>
    

    <!-- Title -->
    
    <title>18张图解密新时代内存分配器TCMalloc - 施展TIGERB</title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/sass/main.css">


    <!--[if lt IE 8]>
        
<script src="/js/ie/html5shiv.js"></script>

    <![endif]-->

    <!--[if lt IE 8]>
        
<link rel="stylesheet" href="/sass/ie8.css">

    <![endif]-->

    <!--[if lt IE 9]>
        
<link rel="stylesheet" href="/sass/ie9.css">

    <![endif]-->

    <!-- Gallery -->
    <link href="https://cdn.bootcss.com/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?30c7e7d53256334a8dc1cf524fcc77f6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
    })();
    </script>

<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div id="wrapper">

        <!-- Menu -->
        <!-- Header -->
<header id="header">
    <div class="inner">

        <!-- Logo -->
        <a href="/" class="logo">
            <span class="symbol"><img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20190707142019.png" alt="" /></span><span class="title">施展TIGERB</span>
        </a>

        <!-- Nav -->
        <nav>
            <ul>
                <li><a href="#menu">Menu</a></li>
            </ul>
        </nav>

    </div>
</header>

<!-- Menu -->
<nav id="menu">
    <h2>Menu</h2>
    <ul>
        
            <li>
                <a href="/">首页</a>
            </li>
        
            <li>
                <a target="_blank" rel="noopener" href="https://github.com/TIGERB">Github</a>
            </li>
        
            <li>
                <a target="_blank" rel="noopener" href="https://segmentfault.com/u/tigerb">Segmentfault</a>
            </li>
        
            <li>
                <a target="_blank" rel="noopener" href="https://juejin.im/user/5855e82d1b69e6006c9278b4">掘金</a>
            </li>
        
    </ul>
</nav>


        <div id="main">
            <div class="inner">

                <!-- Main Content -->
                

    <h1 class="title">18张图解密新时代内存分配器TCMalloc</h1>
    <div class="meta">
        2021-01-31
    </div>


    <span class="image main"><img src="No Code No Life" alt="" /></span>


<!-- Gallery -->


<!-- Content -->
<hr>
<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本系列基于64位平台、1Page=8KB</span><br></pre></td></tr></table></figure>

<p>今天我们开始拉开《Go语言轻松系列》第二章「内存与垃圾回收」的序幕。</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210109200839.png" style="width:30%;box-shadow: 3px 3px 3px 3px #ddd;">
</p>

<p>关于「内存与垃圾回收」章节，大体从如下三大部分展开：</p>
<ul>
<li>知识预备：为后续的内容做一些知识储备，知识预备包括<ul>
<li>指针的大小 <a href="http://tigerb.cn/go/#/kernal/memory-pointer">点击此处查看本文</a></li>
<li>Tcmalloc内存分配原理(本篇内容)</li>
</ul>
</li>
<li>Go内存设计与实现</li>
<li>Go的垃圾回收原理</li>
</ul>
<h1 id="本文导读"><a href="#本文导读" class="headerlink" title="本文导读"></a>本文导读</h1><hr>
<p>我们的主要目的是<strong>掌握Go语言的内存分配原理</strong>。但是呢，Go语言的内存分配主要是基于<strong>Tcmalloc内存分配器</strong>实现的。所以，我们想搞懂Go语言的内存分配原理前，必须先了解<strong>Tcmalloc内存分配器</strong>，以便于我们更好的理解<strong>Go语言的内存分配原理</strong>。</p>
<p>本文目录如下：</p>
<ul>
<li>读前知识储备<ul>
<li>内存的线性分配</li>
<li>什么是<code>FreeList</code>？</li>
<li>虚拟内存</li>
<li>什么是<code>TCMalloc</code>?</li>
</ul>
</li>
<li><code>TCMalloc</code>中的五个基本概念<ul>
<li><code>Page</code>的概念</li>
<li><code>Span</code>的概念<ul>
<li><code>SpanList</code>的概念</li>
</ul>
</li>
<li><code>Object</code>的概念<ul>
<li><code>SizeClass</code>的概念</li>
</ul>
</li>
</ul>
</li>
<li>解密<code>Tcmalloc</code>的基本结构</li>
<li><code>PageHeap</code>、<code>CentralFreeList</code>、<code>ThreadCache</code>的详细构成<ul>
<li>解密<code>PageHeap</code></li>
<li>解密<code>CentralFreeList</code>和<code>TransferCacheManager</code>的构成<ul>
<li>解密<code>CentralFreeList</code></li>
<li>解密<code>TransferCacheManager</code></li>
</ul>
</li>
<li>解密<code>ThreadCache</code></li>
</ul>
</li>
<li>解密<code>TCMalloc</code>基本结构的依赖关系<ul>
<li>简易版</li>
<li>详细版</li>
</ul>
</li>
</ul>
<h1 id="读前知识储备"><a href="#读前知识储备" class="headerlink" title="读前知识储备"></a>读前知识储备</h1><hr>
<p>本小节的内容如下：</p>
<ul>
<li>内存的线性分配</li>
<li>什么是<code>FreeList</code>？</li>
<li>虚拟内存</li>
<li>什么是<code>TCMalloc</code>?</li>
</ul>
<blockquote>
<p>目的：辅助我们更好的理解内存分配原理。</p>
</blockquote>
<h2 id="内存的线性分配"><a href="#内存的线性分配" class="headerlink" title="内存的线性分配"></a>内存的线性分配</h2><hr>
<p>线性分配大致就是需要使用多少分配多少，“用到哪了标识到哪”，如下图所示：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210124225714.png" style="width:100%">
</p>

<p>线性分配有个问题：“已经分配的内存被释放了，我们如何再次分配？”。大家会想到用链表<code>LinkedList</code>，是的没错，但是内存管理中一般使用的是<code>FreeList</code>。</p>
<h2 id="什么是FreeList？"><a href="#什么是FreeList？" class="headerlink" title="什么是FreeList？"></a>什么是FreeList？</h2><hr>
<p><code>FreeList</code>本质上还是个<code>LinkedList</code>，和<code>LinkedList</code>的区别：</p>
<ul>
<li><code>FreeList</code>没有<code>Next</code>属性，所以不是用<code>Next</code>属性存放下一个节点的指针的值。</li>
<li><code>FreeList</code>“相当于使用了<code>Value</code>的前8字节”(其实就是整块内存的前8字节)存放下一个节点的指针。</li>
<li>分配出去的节点，节点整块内存空间可以被复写(指针的值可以被覆盖掉)</li>
</ul>
<p>如下图所示：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210124224723.png" style="width:100%">
</p>

<blockquote>
<p>结论：<code>FreeList</code>里一个节点最小为8字节</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">备注：因为要存指针，指针的大小为8字节，为什么？可以参考上篇文章《64位平台下，指针自身的大小为什么是8字节？》(http://tigerb.cn/2021/01/23/go-base/memory-pointer/)</span><br></pre></td></tr></table></figure>

<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><hr>
<p>这里直说结论哈，我们的进程是运行在虚拟内存上的，图示如下：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210129194928.png" style="width:90%">
</p>

<ul>
<li>对于我们的进程而言，可使用的内存是连续的</li>
<li>安全，防止了进程直接对物理内存的操作(如果进程可以直接操作物理内存，那么存在某个进程篡改其他进程数据的可能)</li>
<li>虚拟内存和物理内存是通过MMU(Memory Manage Unit)映射的(感兴趣的可以研究下)</li>
<li>等等(感兴趣的可以研究下)</li>
</ul>
<p>所以，以下文章我们所说的内存都是指<strong>虚拟内存</strong>。</p>
<h2 id="什么是TCMalloc？"><a href="#什么是TCMalloc？" class="headerlink" title="什么是TCMalloc？"></a>什么是TCMalloc？</h2><hr>
<p><code>TCMalloc</code>全称<code>Thread Cache Alloc</code>，是Google开源的一个内存分配器，基于数据结构<code>FreeList</code>实现，并引入了线程级别的缓存，性能更加优异。</p>
<h1 id="TCMalloc中的五个基本概念"><a href="#TCMalloc中的五个基本概念" class="headerlink" title="TCMalloc中的五个基本概念"></a>TCMalloc中的五个基本概念</h1><hr>
<p>本小节的内容如下：</p>
<ul>
<li><code>Page</code>的概念</li>
<li><code>Span</code>的概念<ul>
<li><code>SpanList</code>的概念</li>
</ul>
</li>
<li><code>Object</code>的概念<ul>
<li><code>SizeClass</code>的概念</li>
</ul>
</li>
</ul>
<blockquote>
<p>目的：<code>TCMalloc</code>各个主要部分是基于这些基本概念组成的.</p>
</blockquote>
<h2 id="Page的概念"><a href="#Page的概念" class="headerlink" title="Page的概念"></a>Page的概念</h2><hr>
<p>操作系统是按<code>Page</code>管理内存的，本文中1Page为8KB，如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">备注：操作系统为什么按`Page`管理内存？不在本文范围。</span><br></pre></td></tr></table></figure>

<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210120131944.png" style="width:100%">
</p>

<h2 id="Span和SpanList的概念"><a href="#Span和SpanList的概念" class="headerlink" title="Span和SpanList的概念"></a>Span和SpanList的概念</h2><hr>
<p>一个<code>Span</code>是由N个<code>Page</code>构成的，且：</p>
<ul>
<li>N的范围为<code>1 ~ +∞</code></li>
<li>构成这个<code>Span</code>的N个<code>Page</code>在内存空间上必须是连续的</li>
</ul>
<p>如下图所示：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210124225012.png" style="width:100%">
</p>

<p>从图中可以看出，有：</p>
<ul>
<li>1个<code>Page</code>构成的8KB的<code>Span</code></li>
<li>2个连续<code>Page</code>构成的16KB的<code>Span</code></li>
<li>3个连续<code>Page</code>构成的24KB的<code>Span</code></li>
</ul>
<p>除此之外，<code>Span</code>和<code>Span</code>之间可以构成<strong>双向链表</strong>我们称之为<code>SpanList</code>，内存管理中通常将持有相同数量<code>Page</code>的<code>Span</code>构成一个双向链表，如下图所示(<strong>N个持有1Page的<code>Span</code>构成的<code>SpanList</code></strong>)：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210128131031.png" style="width:100%">
</p>

<p>我们再来看<code>Span</code>的下代码，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Span</span> : <span class="keyword">public</span> SpanList::Elem &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 略...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把span拆解成object的方法</span></span><br><span class="line">  <span class="comment">// object的概念看下文</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BuildFreelist</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 略...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="comment">// object构成的freelist</span></span><br><span class="line">    <span class="comment">// object的概念看下文</span></span><br><span class="line">    ObjIdx cache_[kCacheSize];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 略...</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  PageId first_page_;  <span class="comment">// 当前span是从哪个page开始的</span></span><br><span class="line">  Length num_pages_;   <span class="comment">// 当前page持有的page数量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 略...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Object和SizeClass的概念"><a href="#Object和SizeClass的概念" class="headerlink" title="Object和SizeClass的概念"></a>Object和SizeClass的概念</h2><hr>
<p>一个<code>Span</code>会被按照某个大小拆分为N个<code>Objects</code>，同时这N个<code>Objects</code>构成一个<code>FreeList</code>(如果忘了FreeList的概念可以再返回上文重新看看)。</p>
<p>我们以持有<code>1Page</code>的<code>Span</code>为例，<code>Span</code>、<code>Page</code>、<code>Object</code>关系图示如下：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210125201952.png" style="width:100%">
</p>

<p>看完上面的图示，问题来了：</p>
<blockquote>
<p>上图怎么知道拆分<code>Span</code>为一个个24字节大小的<code>Object</code>，这个规则是怎么知道的呢？</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">答案：依赖代码维护的映射列表。</span><br><span class="line"></span><br><span class="line">我们以Google开源的TCMalloc源码(commit:<span class="number">9</span>d274df)为例来看一下这个映射列表 https:<span class="comment">//github.com/google/tcmalloc/tree/master/tcmalloc</span></span><br><span class="line"></span><br><span class="line">代码位置：tcmalloc/tcmalloc/size_classes.cc</span><br><span class="line">代码示例(摘取一部分)：</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> SizeClassInfo SizeMap::kSizeClasses[SizeMap::kSizeClassesCount] = &#123;</span><br><span class="line">    <span class="comment">// 这里的每一行 称之为SizeClass</span></span><br><span class="line">    <span class="comment">// &lt;bytes&gt;, &lt;pages&gt;, &lt;batch size&gt;    &lt;fixed&gt;</span></span><br><span class="line">    <span class="comment">// Object大小列，一次申请的page数，一次移动的objects数(内存申请或回收)</span></span><br><span class="line">    &#123;        <span class="number">0</span>,       <span class="number">0</span>,           <span class="number">0</span>&#125;,  <span class="comment">// +Inf%</span></span><br><span class="line">    <span class="comment">// 所以也知道为啥最小8字节了吧？</span></span><br><span class="line">    <span class="comment">// Object会构成FreeList</span></span><br><span class="line">    <span class="comment">// FreeList的节点要存指针</span></span><br><span class="line">    <span class="comment">// 指针为8字节</span></span><br><span class="line">    &#123;        <span class="number">8</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.59%</span></span><br><span class="line">    &#123;       <span class="number">16</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.59%</span></span><br><span class="line">    &#123;       <span class="number">24</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.68%</span></span><br><span class="line">    &#123;       <span class="number">32</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.59%</span></span><br><span class="line">    &#123;       <span class="number">40</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.98%</span></span><br><span class="line">    &#123;       <span class="number">48</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.98%</span></span><br><span class="line">    <span class="comment">// ...略...</span></span><br><span class="line">    &#123;    <span class="number">98304</span>,      <span class="number">12</span>,           <span class="number">2</span>&#125;,  <span class="comment">// 0.05%</span></span><br><span class="line">    &#123;   <span class="number">114688</span>,      <span class="number">14</span>,           <span class="number">2</span>&#125;,  <span class="comment">// 0.04%</span></span><br><span class="line">    &#123;   <span class="number">131072</span>,      <span class="number">16</span>,           <span class="number">2</span>&#125;,  <span class="comment">// 0.04%</span></span><br><span class="line">    &#123;   <span class="number">147456</span>,      <span class="number">18</span>,           <span class="number">2</span>&#125;,  <span class="comment">// 0.03%</span></span><br><span class="line">    &#123;   <span class="number">163840</span>,      <span class="number">20</span>,           <span class="number">2</span>&#125;,  <span class="comment">// 0.03%</span></span><br><span class="line">    &#123;   <span class="number">180224</span>,      <span class="number">22</span>,           <span class="number">2</span>&#125;,  <span class="comment">// 0.03%</span></span><br><span class="line">    &#123;   <span class="number">204800</span>,      <span class="number">25</span>,           <span class="number">2</span>&#125;,  <span class="comment">// 0.02%</span></span><br><span class="line">    &#123;   <span class="number">229376</span>,      <span class="number">28</span>,           <span class="number">2</span>&#125;,  <span class="comment">// 0.02%</span></span><br><span class="line">    &#123;   <span class="number">262144</span>,      <span class="number">32</span>,           <span class="number">2</span>&#125;,  <span class="comment">// 0.02%</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">获取拆分规则的过程(先找到行、再找到这行第一列的值)：</span><br><span class="line"><span class="number">1.</span> 先找到对应行(如何找到这个行？是不是有人有疑惑了，</span><br><span class="line">想知道这个答案就需要了解`CentralFreeList`这个结构了，</span><br><span class="line">下文我们会讲到。)</span><br><span class="line"><span class="number">2.</span> 找到第一列，这个数字就是object的大小</span><br></pre></td></tr></table></figure>

<p>同时通过上面我们知道了：<code>SizeMap::kSizeClasses</code>的每一行元素我们称之为<strong>SizeClass</strong>(下文中我们直接就称之为<code>SizeClass</code>).</p>
<blockquote>
<p>这个5个基本概念具体干什么用的呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">答案：支撑了`Tcmalloc`的基本结构的实现。</span><br></pre></td></tr></table></figure>

<h1 id="解密Tcmalloc的基本结构"><a href="#解密Tcmalloc的基本结构" class="headerlink" title="解密Tcmalloc的基本结构"></a>解密Tcmalloc的基本结构</h1><hr>
<p><code>Tcmalloc</code>主要由三部分构成：</p>
<ul>
<li><code>PageHeap</code></li>
<li><code>CentralFreeList</code></li>
<li><code>ThreadCache</code></li>
</ul>
<p>图示如下：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210120132020.png" style="width:60%">
</p>

<p>但是呢，实际上<code>CentralFreeList</code>是被<code>TransferCacheManager</code>管理的，所以<code>Tcmalloc</code>的基本结构实际应该为下图所示：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210120132031.png" style="width:80%">
</p>

<blockquote>
<p>接着，<code>ThreadCache</code>其实被线程持有，为什么呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">答案：减少线程之间的竞争，分配内存时减少锁的过程。</span><br><span class="line">这也是为什么叫`Thread Cache Alloc`的原因。</span><br></pre></td></tr></table></figure>

<p>进一步得到简易的结构图：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210120132037.png" style="width:80%">
</p>

<h1 id="解密PageHeap、CentralFreeList、ThreadCache的详细构成"><a href="#解密PageHeap、CentralFreeList、ThreadCache的详细构成" class="headerlink" title="解密PageHeap、CentralFreeList、ThreadCache的详细构成"></a>解密PageHeap、CentralFreeList、ThreadCache的详细构成</h1><hr>
<p>本小节的内容如下：</p>
<ul>
<li>解密<code>PageHeap</code></li>
<li>解密<code>CentralFreeList</code>和<code>TransferCacheManager</code>的构成<ul>
<li>解密<code>CentralFreeList</code></li>
<li>解密<code>TransferCacheManager</code></li>
</ul>
</li>
<li>解密<code>ThreadCache</code></li>
</ul>
<blockquote>
<p>目的：详细了解<code>TCMalloc</code>各个组成部分的实现。</p>
</blockquote>
<h2 id="解密PageHeap"><a href="#解密PageHeap" class="headerlink" title="解密PageHeap"></a>解密PageHeap</h2><hr>
<p><code>PageHeap</code>主要负责管理不同规格的<code>Span</code>，相同规格的<code>Span</code>构成<code>SpanList</code>(可回顾上文<code>SpanList</code>的概念)。</p>
<blockquote>
<p>什么是相同规格的<code>Span</code>？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">答：持有相同`Page`数目的`Span`。</span><br></pre></td></tr></table></figure>

<p><code>PageHeap</code>对象里维护了一个属性<code>free_</code>类型是个数组，<strong>粗略看</strong>数组元素的类型是<code>SpanList</code>，同时<code>free_</code>这个数据的元素具有以下特性：</p>
<ul>
<li>索引值为1对应的<code>SpanList</code>，该<code>SpanList</code>的<code>Span</code>都持有1Pages；</li>
<li>索引值为2对应的<code>SpanList</code>，该<code>SpanList</code>的<code>Span</code>都持有2Pages；</li>
<li>以此类推，<code>free_</code>索引值为MaxNumber对应的<code>SpanList</code>，该<code>SpanList</code>的<code>Span</code>都持有MaxNumber Pages；</li>
<li>MaxNumber的值由<code>kMaxPages</code>决定</li>
</ul>
<table>
<thead>
<tr>
<th>数组索引</th>
<th>SpanList里单个Span持有Page数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1Pages</td>
</tr>
<tr>
<td>2</td>
<td>2Pages</td>
</tr>
<tr>
<td>3</td>
<td>3Pages</td>
</tr>
<tr>
<td>4</td>
<td>4Pages</td>
</tr>
<tr>
<td>5</td>
<td>5Pages</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>kMaxPages</td>
<td>kMaxPages Pages</td>
</tr>
</tbody></table>
<p>图示如下：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210129133136.png" style="width:100%">
</p>

<p>但是呢，实际上从代码可知：数组元素的实际类型为<code>SpanListPair</code>，代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PageHeap</span> <span class="keyword">final</span> : <span class="keyword">public</span> PageAllocatorInterface &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 持有两个Span构成的双向链表</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SpanListPair</span> &#123;</span><br><span class="line">    <span class="comment">// Span构成的双向链表 正常的</span></span><br><span class="line">    SpanList normal; </span><br><span class="line">    <span class="comment">// Span构成的双向链表 大概是 物理内存已经回收 但是虚拟内存还被持有(感兴趣可以研究)</span></span><br><span class="line">    SpanList returned;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// kMaxPages.raw_num()这么多个，由上面SpanListPair类型构成的数组</span></span><br><span class="line">  SpanListPair free_[kMaxPages.<span class="built_in">raw_num</span>()] <span class="built_in">ABSL_GUARDED_BY</span>(pageheap_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li><code>free_</code>数组元素的类型是<code>SpanListPair</code></li>
<li><code>SpanListPair</code>里维护了两个<code>SpanList</code></li>
</ul>
<p>根据这个结论我们修正下<code>PageHeap</code>结构图，如下：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210129132903.png" style="width:100%">
</p>

<p>又因为大于kMaxPages个Pages(大对象)的内存分配是从<code>large_</code>中分配的，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PageHeap</span> <span class="keyword">final</span> : <span class="keyword">public</span> PageAllocatorInterface &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  大对象的内存从这里分配(length &gt;= kMaxPages)</span></span><br><span class="line">  <span class="function">SpanListPair large_ <span class="title">ABSL_GUARDED_BY</span><span class="params">(pageheap_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们再加上大对象的分配时的<code>large_</code>属性，得到<code>PageHeap</code>的结构图如下：</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210129132923.png" style="width:100%">
</p>

<p>同时<code>PageHeap</code>核心的代码片段如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PageHeap</span> <span class="keyword">final</span> : <span class="keyword">public</span> PageAllocatorInterface &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 持有两个Span构成的双向链表</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SpanListPair</span> &#123;</span><br><span class="line">    <span class="comment">// Span构成的双向链表</span></span><br><span class="line">    SpanList normal; </span><br><span class="line">    <span class="comment">// Span构成的双向链表</span></span><br><span class="line">    SpanList returned;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  大对象的内存从这里分配(length &gt;= kMaxPages)</span></span><br><span class="line">  <span class="function">SpanListPair large_ <span class="title">ABSL_GUARDED_BY</span><span class="params">(pageheap_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// kMaxPages.raw_num()这么多个，由上面SpanListPair类型构成的数组</span></span><br><span class="line">  SpanListPair free_[kMaxPages.<span class="built_in">raw_num</span>()] <span class="built_in">ABSL_GUARDED_BY</span>(pageheap_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解密CentralFreeList和TransferCacheManager的构成"><a href="#解密CentralFreeList和TransferCacheManager的构成" class="headerlink" title="解密CentralFreeList和TransferCacheManager的构成"></a>解密CentralFreeList和TransferCacheManager的构成</h2><hr>
<h3 id="解密CentralFreeList"><a href="#解密CentralFreeList" class="headerlink" title="解密CentralFreeList"></a>解密CentralFreeList</h3><hr>
<p>我们可以称之为中央缓存，中央缓存被线程共享，从中央缓存<code>CentralFreeList</code>获取缓存需要加锁。</p>
<p><code>CentralFreeList</code>里面有个属性<code>size_class_</code>，就是<code>SizeClass</code>的值，来自于映射表<code>SizeMap</code>这个数组的索引值。<code>CentralFreeList</code>里的<code>Span</code>会做一件事情，按照这个<code>size_class_</code>值对应的规则拆解<code>Span</code>为多个<code>Object</code>，同时这些<code>Object</code>构成<code>FreeList</code>。</p>
<p>同时，<code>SizeMap</code>里的每个<code>SizeClass</code>都会对应一个<code>CentralFreeList</code>，所以最多一共会有N个<code>CentralFreeList</code>，N的值为<code>kNumClasses</code>。关键代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CentralFreeList</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁</span></span><br><span class="line">  <span class="comment">// 线程从此处获取内存 需要加锁 保证并发安全</span></span><br><span class="line">  absl::base_internal::SpinLock lock_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应上文提到的映射表SizeClassInfo中的某个索引值</span></span><br><span class="line">  <span class="comment">// 目的找到Span拆解为object时，object的大小等规则</span></span><br><span class="line">  <span class="type">size_t</span> size_class_;  </span><br><span class="line">  <span class="comment">// object的总数量</span></span><br><span class="line">  <span class="type">size_t</span> object_size_;</span><br><span class="line">  <span class="comment">// 一个Span持有的object的数量</span></span><br><span class="line">  <span class="type">size_t</span> objects_per_span_;</span><br><span class="line">  <span class="comment">// 一个Span持有的page的数量</span></span><br><span class="line">  Length pages_per_span_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略</span></span><br></pre></td></tr></table></figure>

<p>如下图就展示了<code>kNumClasses</code>个<code>CentralFreeList</code>，其中我们以<code>size_class_</code>的值为<code>1</code>和<code>3</code>为例来展示下<code>CentralFreeList</code>的结构。</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210120132206.png" style="width:100%">
</p>

<h3 id="解密TransferCacheManager"><a href="#解密TransferCacheManager" class="headerlink" title="解密TransferCacheManager"></a>解密TransferCacheManager</h3><hr>
<p>因为有<code>kNumClasses</code>个<code>CentralFreeList</code>，这些<code>CentralFreeList</code>在哪维护的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">答案：就是`TransferCacheManager`这个结构里的`freelist_`属性。</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransferCacheManager</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// freelist_是个数组</span></span><br><span class="line">  <span class="comment">// 元素的类型是上面的CentralFreeList</span></span><br><span class="line">  <span class="comment">// 元素的数量与 映射表 SizeClassInfo对应</span></span><br><span class="line">  CentralFreeList freelist_[kNumClasses];</span><br><span class="line">&#125; ABSL_CACHELINE_ALIGNED;</span><br></pre></td></tr></table></figure>

<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210120132218.png" style="width:100%">
</p>


<h2 id="解密ThreadCache的构成"><a href="#解密ThreadCache的构成" class="headerlink" title="解密ThreadCache的构成"></a>解密ThreadCache的构成</h2><hr>
<p>我们可以称之为线程缓存，<code>TCMalloc</code>内存分配器的核心所在。<code>ThreadCache</code>被每个线程持有，分配内存时不用加锁，性能好。</p>
<p><code>ThreadCache</code>对象里维护了一个属性<code>list_</code>类型是个数组，数组元素的类型是<code>FreeList</code>，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadCache</span> &#123;</span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// list_是个数组</span></span><br><span class="line">  <span class="comment">// 元素的类型是FreeList</span></span><br><span class="line">  <span class="comment">// 元素的数量与 映射表 SizeClassInfo对应</span></span><br><span class="line">  FreeList list_[kNumClasses]; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时<code>FreeList</code>里的元素还具有以下特性：</p>
<ul>
<li>索引值为1对应的<code>FreeList</code>，该<code>FreeList</code>的<code>Object</code>大小为8 Bytes；</li>
<li>索引值为2对应的<code>FreeList</code>，该<code>FreeList</code>的<code>Object</code>大小为16 Bytes；</li>
<li>以此类推，<code>free_</code>索引值为MaxNumber对应的<code>FreeList</code>，该<code>FreeList</code>的<code>Object</code>大小为MaxNumber Bytes；</li>
<li>MaxNumber的值由<code>kNumClasses</code>决定</li>
</ul>
<p>这个规则怎么来的？还是取决于映射列表，同样以Google开源的TCMalloc源码(commit:9d274df)为例，来看一下这个映射列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//github.com/google/tcmalloc/tree/master/tcmalloc</span></span><br><span class="line"></span><br><span class="line">代码位置：tcmalloc/tcmalloc/size_classes.cc</span><br><span class="line">代码示例(摘取一部分)：</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> SizeClassInfo SizeMap::kSizeClasses[SizeMap::kSizeClassesCount] = &#123;</span><br><span class="line">    <span class="comment">// 这里的每一行 称之为SizeClass</span></span><br><span class="line">    <span class="comment">// &lt;bytes&gt;, &lt;pages&gt;, &lt;batch size&gt;    &lt;fixed&gt;</span></span><br><span class="line">    <span class="comment">// Object大小列，一次申请的page数，一次移动的objects数(内存申请或回收)</span></span><br><span class="line">    &#123;        <span class="number">0</span>,       <span class="number">0</span>,           <span class="number">0</span>&#125;,  <span class="comment">// +Inf%</span></span><br><span class="line">    &#123;        <span class="number">8</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.59%</span></span><br><span class="line">    &#123;       <span class="number">16</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.59%</span></span><br><span class="line">    &#123;       <span class="number">24</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.68%</span></span><br><span class="line">    &#123;       <span class="number">32</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.59%</span></span><br><span class="line">    &#123;       <span class="number">40</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.98%</span></span><br><span class="line">    &#123;       <span class="number">48</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.98%</span></span><br><span class="line">    <span class="comment">// ...略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以得到：</p>
<table>
<thead>
<tr>
<th>数组索引</th>
<th>FreeList里单个Object的大小</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>8 Bytes</td>
</tr>
<tr>
<td>2</td>
<td>16 Bytes</td>
</tr>
<tr>
<td>3</td>
<td>24 Bytes</td>
</tr>
<tr>
<td>4</td>
<td>32 Bytes</td>
</tr>
<tr>
<td>5</td>
<td>40 Bytes</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>kNumClasses</td>
<td>kNumClasses Bytes</td>
</tr>
</tbody></table>
<p>得到<code>ThreadCache</code>结构图如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：图示中索引为3的FreeList的Span尾部会浪费掉8字节。</span><br></pre></td></tr></table></figure>

<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210120132229.png" style="width:100%">
</p>

<h1 id="解密Tcmalloc基本结构的依赖关系"><a href="#解密Tcmalloc基本结构的依赖关系" class="headerlink" title="解密Tcmalloc基本结构的依赖关系"></a>解密Tcmalloc基本结构的依赖关系</h1><hr>
<p>本小节的内容如下：</p>
<ul>
<li>简易版</li>
<li>详细版</li>
</ul>
<blockquote>
<p>目的：了解<code>Tcmalloc</code>内存分配的大致过程。</p>
</blockquote>
<h2 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h2><hr>
<p>我们把<code>Tcmalloc</code>中分配的对象分为两类：</p>
<ul>
<li>小对象</li>
<li>非小对象</li>
</ul>
<p>小对象的大小范围就来自于<code>SizeMap</code>维护的映射表，也就是单个<code>Object</code>的大小范围，我们还是以如下代码片段为例，可知单个<code>Object</code>大小范围为：</p>
<blockquote>
<p>8 Byte ~ 262144 Byte &#x3D;&#x3D; 8 Byte ~ 256 KB</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> SizeClassInfo SizeMap::kSizeClasses[SizeMap::kSizeClassesCount] = &#123;</span><br><span class="line">    <span class="comment">// 这里的每一行 称之为SizeClass</span></span><br><span class="line">    <span class="comment">// &lt;bytes&gt;, &lt;pages&gt;, &lt;batch size&gt;    &lt;fixed&gt;</span></span><br><span class="line">    <span class="comment">// Object大小列，一次申请的page数，一次移动的objects数(内存申请或回收)</span></span><br><span class="line">    <span class="comment">// ...略...</span></span><br><span class="line">    &#123;        <span class="number">8</span>,       <span class="number">1</span>,          <span class="number">32</span>&#125;,  <span class="comment">// 0.59%</span></span><br><span class="line">    <span class="comment">// ...略...</span></span><br><span class="line">    &#123;   <span class="number">262144</span>,      <span class="number">32</span>,           <span class="number">2</span>&#125;,  <span class="comment">// 0.02%</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>小对象</td>
<td>&lt;&#x3D; 256 KB</td>
<td><code>ThreadCache</code>、<code>CentralFreeList</code></td>
</tr>
<tr>
<td>非小对象</td>
<td>&gt; 256 KB</td>
<td><code>PageHeap.free_</code>和<code>PageHeap.large_</code></td>
</tr>
</tbody></table>
<p>当给小对象分配内存时：<code>ThreadCache</code>的内存不足时，从对应<code>SizeClass</code>的<code>CentralFreeList</code>获取，如果获取不到，<code>CentralFreeList</code>再从<code>PageHeap</code>里获取内存。</p>
<p>当给非小对象分配内存时：<code>PageHeap.free_</code>和<code>PageHeap.large_</code>里获取。</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210131211533.png" style="width:66%">
</p>

<h1 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h1><hr>
<p>最后，我们以获取<code>6</code>字节的小对象为例(<code>SizeClass</code>的值为<code>1</code>)，看一下详细内存分配过程。</p>
<p align="center">
  <img src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20210131212110.png" style="width:100%">
</p>


<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><hr>
<p>简单总结下，本篇文章我们可以获取到的知识点：</p>
<ul>
<li>了解了<code>FreeList</code></li>
<li>知道了<code>TCMalloc</code>主要由<code>ThreadCache</code>、<code>CentralFreeList</code>、<code>PageHeap</code>三部分组成<ul>
<li><code>Object</code>构成的<code>FreeList</code>，被<code>ThreadCache</code>维护</li>
<li><code>Span</code>构成了<code>SpanList</code>，被<code>CentralFreeList</code>维护，同时<code>Span</code>会被拆解成<code>Object</code></li>
<li>当<code>ThreadCache</code>里的<code>Object</code>没有时，从对应<code>SizeClass</code>的<code>CentralFreeList</code>里获取</li>
<li>小对象来自<code>ThreadCache</code>、<code>CentralFreeList</code></li>
<li>非小对象来自<code>PageHeap</code></li>
</ul>
</li>
<li>线程从<code>ThreadCache</code>获取内存不需要加锁</li>
</ul>
<p>通过学习以上内容，再回过头学习Go语言的内存分配，应该会变得轻松明了，下次我们就来看看Go内存设计与实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考：</span><br><span class="line">1. tcmalloc源码(commit:9d274df) https://github.com/google/tcmalloc/tree/master/tcmalloc</span><br><span class="line">2. 可利用空间表（Free List）https://songlee24.github.io/2015/04/08/free-list/</span><br><span class="line">3. 图解 TCMalloc https://zhuanlan.zhihu.com/p/29216091</span><br><span class="line">4. TCMalloc解密 https://wallenwang.com/2018/11/tcmalloc/</span><br><span class="line">5. TCMalloc : Thread-Caching Malloc https://github.com/google/tcmalloc/blob/master/docs/design.md</span><br><span class="line">6. TCMalloc : Thread-Caching Malloc https://gperftools.github.io/gperftools/tcmalloc.html</span><br><span class="line">7. tcmalloc原理剖析(基于gperftools-2.1) http://gao-xiao-long.github.io/2017/11/25/tcmalloc/</span><br></pre></td></tr></table></figure>

<!-- Tags -->



<div class="tags">
    <a href="/tags/Go/" class="button small">Go</a>
</div>



<!-- Qrcode -->
<div width="100px">
    <img src="https://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/wechat-blog-qrcode.jpg" alt="TIGERB" width="300px" style="display:block; margin: 30px auto 0px auto;">
</div>

<!-- Comments -->
<div>
    


</div>



            </div>
        </div>

        <!-- Footer -->
<footer id="footer">
    <div class="inner">
        <section>
            <h2>About</h2>
            <div>
                新一代轻量级「<a target="_blank" rel="noopener" href='http://easy-php.tigerb.cn'>EasyPHP</a>」框架作者，<a href="/php2go/#/">「《PHP到Go速转手册》」作者</a>，「<a target="_blank" rel="noopener" href='http://skrshop.tech/'>《电商设计手册 | SkrShop》</a>」作者，「<a href='http://tigerb.cn/go/#/patterns/'>《Go设计模式实战》系列</a>」作者，「<a href='http://tigerb.cn/go/#/kernal/'>《Go语言轻松进阶》系列</a>」作者。现世界500强技术经理，拥有丰富的架构、电商系统设计、高并发、体系流程建设和管理经验。<br><br><img style="vertical-align:middle" width="30%" src="http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/wechat-blog-qrcode.jpg?imageMogr2/thumbnail/260x260!/format/webp/blur/1x0/quality/90|imageslim">
            </div>
        </section>
        <section>
            <h2>Follow</h2>
            <ul class="icons">
                
                    <li><a href="https://twitter.com/CODERCOOKER" class="icon style2 fa-twitter" target="_blank" ><span class="label">Twitter</span></a></li>
                
                
                
                
                
                    <li><a href="https://github.com/TIGERB" class="icon style2 fa-github" target="_blank" ><span class="label">GitHub</span></a></li>
                
                
                
                
                
                    <li><a href="mailto:tigerbcode@gmail.com" class="icon style2 fa-envelope-o" target="_blank" ><span class="label">Email</span></a></li>
                
                
                    <li><a href="\atom.xml" class="icon style2 fa-rss" target="_blank" ><span class="label">RSS</span></a></li>
                
            </ul>
        </section>
        <ul class="copyright">
            <li>&copy; TIGERB.cn All right reserved. 津ICP备17006784号-2</li>
            <li><a href="https://juejin.im/user/5855e82d1b69e6006c9278b4" target="_blank">juejin</a></li>
            <li><a href="https://segmentfault.com/u/tigerb" target="_blank">Segmentfault</a></li>
            <li><a target="_blank" rel="noopener" href="http://skrshop.tech/">电商设计手册 | SkrShop</a></li>
            <li><a href="http://tigerb.cn/go/#/patterns/">Go设计模式实战</a></li>
            <li><a href="http://tigerb.cn/go/#/kernal/">Go语言轻松进阶</a></li>
            <li><a target="_blank" rel="noopener" href="https://dayutalk.cn/">大愚Talk</a></li>
        </ul>
    </div>
</footer>
    </div>

    <!-- After footer scripts -->
    
<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- skel -->

<script src="/js/skel.min.js"></script>


<!-- Custom Code -->

<script src="/js/util.js"></script>


<!--[if lte IE 8]>

<script src="/js/ie/respond.min.js"></script>

<![endif]-->

<!-- Custom Code -->

<script src="/js/main.js"></script>


<!-- Gallery -->
<script src="https://cdn.bootcss.com/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->


</body>

</html>