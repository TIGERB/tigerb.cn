<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="Trying to be the person you want to be.">
    

    <!--Author-->
    
        <meta name="author" content="TIGERB">
    

    <!--Open Graph Title-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="TIGERB"/>

    <!--Page Cover-->
    
        <meta property="og:image" content="undefined"/>
    

    <!-- Title -->
    
    <title>TIGERB</title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/sass/main.css">

    <!--[if lt IE 8]>
        <script src="/js/ie/html5shiv.js"></script>
    <![endif]-->

    <!--[if lt IE 8]>
        <link rel="stylesheet" href="/sass/ie8.css">
    <![endif]-->

    <!--[if lt IE 9]>
        <link rel="stylesheet" href="/sass/ie9.css">
    <![endif]-->

    <!-- Gallery -->
    <link href="https://cdn.bootcss.com/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?30c7e7d53256334a8dc1cf524fcc77f6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>

<body>

    <div id="wrapper">

        <!-- Menu -->
        <!-- Header -->
<header id="header">
    <div class="inner">

        <!-- Logo -->
        <a href="/" class="logo">
            <span class="symbol"><img src="http://cdn.tigerb.cn/20190707142019.png" alt="" /></span><span class="title">TIGERB</span>
        </a>

        <!-- Nav -->
        <nav>
            <ul>
                <li><a href="#menu">Menu</a></li>
            </ul>
        </nav>

    </div>
</header>

<!-- Menu -->
<nav id="menu">
    <h2>Menu</h2>
    <ul>
        
            <li>
                <a href="/">首页</a>
            </li>
        
            <li>
                <a href="https://github.com/TIGERB">Github</a>
            </li>
        
            <li>
                <a href="https://segmentfault.com/u/tigerb">Segmentfault</a>
            </li>
        
            <li>
                <a href="https://juejin.im/user/5855e82d1b69e6006c9278b4">掘金</a>
            </li>
        
    </ul>
</nav>


        <div id="main">
            <div class="inner">

                <!-- Main Content -->
                

    <h1 class="title">No Code No Life</h1>
    <div class="meta">
        2020-11-04
    </div>


<span class="image main"><img src="No Code No Life" alt="" /></span>


<!-- Gallery -->


<!-- Content -->
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1="" align="center">Go设计模式实战 | 我的代码没有else系列

<p align="center"><br>    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-Hans" target="_blank" rel="noopener"><br>        <a href="https://img.shields.io/badge/License-CC%20BY--NC--ND%204.0-red" title="Lisense" class="gallery-item" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/License-CC%20BY--NC--ND%204.0-red" alt="Lisense"></a><br>    </a><br></p>

<blockquote>
<p>嗯，Go设计模式实战系列，一个设计模式业务真实使用的golang系列。</p>
</blockquote>
<p><br>    <a href="http://cdn.tigerb.cn/20201103130617.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20201103130617.png" width="36%"></a><br></p>

<h1 id="版权申明"><a href="#版权申明" class="headerlink" title="版权申明"></a>版权申明</h1><ul>
<li>未经版权所有者明确授权，禁止发行本手册及其被实质上修改的版本。 </li>
<li>未经版权所有者事先授权，禁止将此作品及其衍生作品以标准（纸质）书籍形式发行。</li>
</ul>
<p><br>    <a href="http://cdn.tigerb.cn/wechat-blog-qrcode.jpg?imageMogr2/thumbnail/260x260!/format/webp/blur/1x0/quality/90|imageslim" class="gallery-item" target="_blank" rel="noopener"><img style="vertical-align:middle" width="20%" src="http://cdn.tigerb.cn/wechat-blog-qrcode.jpg?imageMogr2/thumbnail/260x260!/format/webp/blur/1x0/quality/90|imageslim"></a><br></p><p><br><br># 目标<br><br>- 重读设计模式，温故知新<br>- Golang设计模式实战，完全结合真实的业务场景去运用设计模式<br>- 简化大家对设计模式的理解<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">特别说明：</span><br><span class="line">本系列的一些设计模式的概念可能和原概念存在差异，因为会结合实际使用，取其精华，适当改变，灵活使用。</span><br></pre></td></tr></table></figure><br><br># 目录<br><br>- <a href="#前言">前言</a><br>- <a href="#模板模式">模板模式</a><br>- <a href="#责任链模式">责任链模式</a><br>- <a href="#组合模式">组合模式</a><br>- <a href="#观察者模式">观察者模式</a><br>- <a href="#策略模式">策略模式</a><br>- <a href="#状态模式">状态模式</a><br>- <a href="#并发组合模式">并发组合模式</a><br>- TODO<br><br># 前言<br><br>本系列主要分享，如何在我们的真实业务场景中使用设计模式。<br><br>本系列文章主要采用如下结构：<br><br>- 什么是「XX设计模式」？<br>- 什么真实业务场景可以使用「XX设计模式」？<br>- 怎么用「XX设计模式」？<br><br>本文主要介绍「模板模式」如何在真实业务场景中使用。<br><br># 模板模式<br><br>## 什么是「模板模式」？<br><br>抽象类里定义好<strong>算法的执行步骤</strong>和<strong>具体算法</strong>，以及可能发生变化的算法定义为<strong>抽象方法</strong>。不同的子类继承该抽象类，并实现父类的抽象方法。<br><br>模板模式的优势：<br><br>- 不变的算法被继承复用：不变的部分高度封装、复用。<br>- 变化的算法子类继承并具体实现：变化的部分子类只需要具体实现抽象的部分即可，方便扩展，且可无限扩展。<br><br>## 什么真实业务场景可以用「模板模式」？<br><br>满足如下要求的所有场景:<br><br>&gt; 算法执行的步骤是稳定<strong>不变的</strong>，但是具体的某些算法可能存在<strong>变</strong>化的场景。<br><br>怎么理解，举个例子：<code>比如说你煮个面，必然需要先烧水，水烧开之后再放面进去</code>，以上的流程我们称之为<code>煮面过程</code>。可知：这个<code>煮面过程</code>的步骤是稳定不变的，但是在不同的环境烧水的方式可能不尽相同，也许有的人用天然气烧水、有的人用电磁炉烧水、有的人用柴火烧水，等等。我们可以得到以下结论：<br><br>- <code>煮面过程</code>的步骤是稳定不变的<br>- <code>煮面过程</code>的烧水方式是可变的<br><br>&gt; 我们有哪些真实业务场景可以用「模板模式」呢？<br><br>比如抽奖系统的抽奖接口，为什么：<br><br>- 抽奖的步骤是稳定不变的 -&gt; <strong>不变的</strong>算法执行步骤<br>- 不同抽奖类型活动在某些逻辑处理方式可能不同 -&gt; <strong>变的</strong>某些算法<br><br>## 怎么用「模板模式」？<br><br>关于怎么用，完全可以生搬硬套我总结的使用设计模式的四个步骤：<br><br>- 业务梳理<br>- 业务流程图<br>- 代码建模<br>- 代码demo<br><br>#### 业务梳理<br><br>我通过历史上接触过的各种抽奖场景（红包雨、糖果雨、打地鼠、大转盘(九宫格)、考眼力、答题闯关、游戏闯关、支付刮刮乐、积分刮刮乐等等），按照真实业务需求梳理了以下抽奖业务抽奖接口的大致文本流程。<br><br>了解具体业务请点击<a href="http://tigerb.cn/2019/12/23/skr-lottery/">《通用抽奖工具之需求分析 | SkrShop》</a><br><br>主步骤|主逻辑|抽奖类型|子步骤|子逻辑<br>—|——-|—|——-|——-<br>1|校验活动编号(serial_no)是否存在、并获取活动信息|-|-|-<br>2|校验活动、场次是否正在进行|-|-|-<br>3|其他参数校验(<strong>不同活动类型实现不同</strong>)|-|-|-<br>4|活动抽奖次数校验(同时扣减)|-|-|-<br>5|活动是否需要消费积分|-|-|-<br>6|场次抽奖次数校验(同时扣减)|-|-|-<br>7|获取场次奖品信息|-|-|-<br>8|获取node奖品信息(<strong>不同活动类型实现不同</strong>)|<strong>按时间抽奖类型</strong>|1|do nothing(抽取该场次的奖品即可，无需其他逻辑)<br>8||<strong>按抽奖次数抽奖类型</strong>|1|判断是该用户第几次抽奖<br>8|||2|获取对应node的奖品信息<br>8|||3|复写原所有奖品信息(抽取该node节点的奖品)<br>8||<strong>按数额范围区间抽奖</strong>|1|判断属于哪个数额区间<br>8|||2|获取对应node的奖品信息<br>8|||3|复写原所有奖品信息(抽取该node节点的奖品)<br>9|抽奖|-|-|-<br>10|奖品数量判断|-|-|-<br>11|组装奖品信息|-|-|-<br><br>&gt; 注：流程不一定完全准确<br><br>结论：<br><br>- <code>主逻辑</code>是稳定不变的<br>- <code>其他参数校验</code>和<code>获取node奖品信息</code>的算法是可变的<br><br>#### 业务流程图<br><br>我们通过梳理的文本业务流程得到了如下的业务流程图：<br><br><a href="http://cdn.tigerb.cn/20200325205347.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200325205347.png" alt=""></a><br><br>#### 代码建模<br><br>通过上面的分析我们可以得到：<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个抽象类</span><br><span class="line">- 具体共有方法`Run`，里面定义了算法的执行步骤</span><br><span class="line">- 具体私有方法，不会发生变化的具体方法</span><br><span class="line">- 抽象方法，会发生变化的方法</span><br><span class="line"></span><br><span class="line">子类一(按时间抽奖类型)</span><br><span class="line">- 继承抽象类父类</span><br><span class="line">- 实现抽象方法</span><br><span class="line"></span><br><span class="line">子类二(按抽奖次数抽奖类型)</span><br><span class="line">- 继承抽象类父类</span><br><span class="line">- 实现抽象方法</span><br><span class="line"></span><br><span class="line">子类三(按数额范围区间抽奖)</span><br><span class="line">- 继承抽象类父类</span><br><span class="line">- 实现抽象方法</span><br></pre></td></tr></table></figure><br><br>但是golang里面没有继承的概念，我们就把对抽象类里抽象方法的依赖转化成对接口<code>interface</code>里抽象方法的依赖，同时也可以利用<code>合成复用</code>的方式“继承”模板:<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">抽象行为的接口`BehaviorInterface`(包含如下需要实现的方法)</span><br><span class="line">- 其他参数校验的方法`checkParams`</span><br><span class="line">- 获取node奖品信息的方法`getPrizesByNode`</span><br><span class="line"></span><br><span class="line">抽奖结构体类</span><br><span class="line">- 具体共有方法`Run`，里面定义了算法的执行步骤</span><br><span class="line">- 具体私有方法`checkParams` 里面的逻辑实际依赖的接口BehaviorInterface.checkParams(ctx)的抽象方法</span><br><span class="line">- 具体私有方法`getPrizesByNode` 里面的逻辑实际依赖的接口BehaviorInterface.getPrizesByNode(ctx)的抽象方法</span><br><span class="line">- 其他具体私有方法，不会发生变化的具体方法</span><br><span class="line"></span><br><span class="line">实现`BehaviorInterface`的结构体一(按时间抽奖类型)</span><br><span class="line">- 实现接口方法</span><br><span class="line"></span><br><span class="line">实现`BehaviorInterface`的结构体二(按抽奖次数抽奖类型)</span><br><span class="line">- 实现接口方法</span><br><span class="line"></span><br><span class="line">实现`BehaviorInterface`的结构体三(按数额范围区间抽奖)</span><br><span class="line">- 实现接口方法</span><br></pre></td></tr></table></figure><br><br>同时得到了我们的UML图：<br><br><a href="http://cdn.tigerb.cn/20200326201327.jpg" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200326201327.jpg" alt=""></a><br><br>#### 代码demo<br><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Go设计模式实战系列</span></span><br><span class="line"><span class="comment">//模板模式</span></span><br><span class="line"><span class="comment">//@auhtor TIGERB&lt;https://github.com/TIGERB&gt;</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// ConstActTypeTime 按时间抽奖类型</span></span><br><span class="line">	ConstActTypeTime <span class="keyword">int32</span> = <span class="number">1</span></span><br><span class="line">	<span class="comment">// ConstActTypeTimes 按抽奖次数抽奖</span></span><br><span class="line">	ConstActTypeTimes <span class="keyword">int32</span> = <span class="number">2</span></span><br><span class="line">	<span class="comment">// ConstActTypeAmount 按数额范围区间抽奖</span></span><br><span class="line">	ConstActTypeAmount <span class="keyword">int32</span> = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context 上下文</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	ActInfo *ActInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActInfo 上下文</span></span><br><span class="line"><span class="keyword">type</span> ActInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 活动抽奖类型1: 按时间抽奖 2: 按抽奖次数抽奖 3:按数额范围区间抽奖</span></span><br><span class="line">	ActivityType <span class="keyword">int32</span></span><br><span class="line">	<span class="comment">// 其他字段略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BehaviorInterface 不同抽奖类型的行为差异的抽象接口</span></span><br><span class="line"><span class="keyword">type</span> BehaviorInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 其他参数校验(不同活动类型实现不同)</span></span><br><span class="line">	checkParams(ctx *Context) error</span><br><span class="line">	<span class="comment">// 获取node奖品信息(不同活动类型实现不同)</span></span><br><span class="line">	getPrizesByNode(ctx *Context) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TimeDraw 具体抽奖行为</span></span><br><span class="line"><span class="comment">// 按时间抽奖类型 比如红包雨</span></span><br><span class="line"><span class="keyword">type</span> TimeDraw <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkParams 其他参数校验(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw TimeDraw)</span> <span class="title">checkParams</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"按时间抽奖类型:特殊参数校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrizesByNode 获取node奖品信息(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw TimeDraw)</span> <span class="title">getPrizesByNode</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"do nothing(抽取该场次的奖品即可，无需其他逻辑)..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TimesDraw 具体抽奖行为</span></span><br><span class="line"><span class="comment">// 按抽奖次数抽奖类型 比如答题闯关</span></span><br><span class="line"><span class="keyword">type</span> TimesDraw <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkParams 其他参数校验(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw TimesDraw)</span> <span class="title">checkParams</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"按抽奖次数抽奖类型:特殊参数校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrizesByNode 获取node奖品信息(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw TimesDraw)</span> <span class="title">getPrizesByNode</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"1. 判断是该用户第几次抽奖..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"2. 获取对应node的奖品信息..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"3. 复写原所有奖品信息(抽取该node节点的奖品)..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AmountDraw 具体抽奖行为</span></span><br><span class="line"><span class="comment">// 按数额范围区间抽奖 比如订单金额刮奖</span></span><br><span class="line"><span class="keyword">type</span> AmountDraw <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkParams 其他参数校验(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw *AmountDraw)</span> <span class="title">checkParams</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"按数额范围区间抽奖:特殊参数校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrizesByNode 获取node奖品信息(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw *AmountDraw)</span> <span class="title">getPrizesByNode</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"1. 判断属于哪个数额区间..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"2. 获取对应node的奖品信息..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"3. 复写原所有奖品信息(抽取该node节点的奖品)..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lottery 抽奖模板</span></span><br><span class="line"><span class="keyword">type</span> Lottery <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 不同抽奖类型的抽象行为</span></span><br><span class="line">	concreteBehavior BehaviorInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run 抽奖算法</span></span><br><span class="line"><span class="comment">// 稳定不变的算法步骤</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">Run</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 具体方法：校验活动编号(serial_no)是否存在、并获取活动信息</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkSerialNo(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：校验活动、场次是否正在进行</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkStatus(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ”抽象方法“：其他参数校验</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkParams(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：活动抽奖次数校验(同时扣减)</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkTimesByAct(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：活动是否需要消费积分</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.consumePointsByAct(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：场次抽奖次数校验(同时扣减)</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkTimesBySession(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：获取场次奖品信息</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.getPrizesBySession(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ”抽象方法“：获取node奖品信息</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.getPrizesByNode(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：抽奖</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.drawPrizes(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：奖品数量判断</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkPrizesStock(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：组装奖品信息</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.packagePrizeInfo(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkSerialNo 校验活动编号(serial_no)是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkSerialNo</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"校验活动编号(serial_no)是否存在、并获取活动信息..."</span>)</span><br><span class="line">	<span class="comment">// 获取活动信息伪代码</span></span><br><span class="line">	ctx.ActInfo = &amp;ActInfo&#123;</span><br><span class="line">	<span class="comment">// 假设当前的活动类型为按抽奖次数抽奖</span></span><br><span class="line">	ActivityType: ConstActTypeTimes,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前抽奖类型的具体行为</span></span><br><span class="line">	<span class="keyword">switch</span> ctx.ActInfo.ActivityType &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="comment">// 按时间抽奖</span></span><br><span class="line">	lottery.concreteBehavior = &amp;TimeDraw&#123;&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	<span class="comment">// 按抽奖次数抽奖</span></span><br><span class="line">	lottery.concreteBehavior = &amp;TimesDraw&#123;&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	<span class="comment">// 按数额范围区间抽奖</span></span><br><span class="line">	lottery.concreteBehavior = &amp;AmountDraw&#123;&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"不存在的活动类型"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkStatus 校验活动、场次是否正在进行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkStatus</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"校验活动、场次是否正在进行..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkParams 其他参数校验(不同活动类型实现不同)</span></span><br><span class="line"><span class="comment">// 不同场景变化的算法 转化为依赖抽象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkParams</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 实际依赖的接口的抽象方法</span></span><br><span class="line">	<span class="keyword">return</span> lottery.concreteBehavior.checkParams(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkTimesByAct 活动抽奖次数校验</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkTimesByAct</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"活动抽奖次数校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consumePointsByAct 活动是否需要消费积分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">consumePointsByAct</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"活动是否需要消费积分..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkTimesBySession 活动抽奖次数校验</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkTimesBySession</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"活动抽奖次数校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrizesBySession 获取场次奖品信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">getPrizesBySession</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取场次奖品信息..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrizesByNode 获取node奖品信息(不同活动类型实现不同)</span></span><br><span class="line"><span class="comment">// 不同场景变化的算法 转化为依赖抽象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">getPrizesByNode</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 实际依赖的接口的抽象方法</span></span><br><span class="line">	<span class="keyword">return</span> lottery.concreteBehavior.getPrizesByNode(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drawPrizes 抽奖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">drawPrizes</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"抽奖..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkPrizesStock 奖品数量判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkPrizesStock</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"奖品数量判断..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packagePrizeInfo 组装奖品信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">packagePrizeInfo</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"组装奖品信息..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	(&amp;Lottery&#123;&#125;).Run(&amp;Context&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取正在运行的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFuncName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	pc := <span class="built_in">make</span>([]<span class="keyword">uintptr</span>, <span class="number">1</span>)</span><br><span class="line">	runtime.Callers(<span class="number">2</span>, pc)</span><br><span class="line">	f := runtime.FuncForPC(pc[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> f.Name()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>以下是代码执行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Running] go run &quot;.../easy-tips/go/src/patterns/template/template.go&quot;</span><br><span class="line">main.(*Lottery).checkSerialNo 校验活动编号(serial_no)是否存在、并获取活动信息...</span><br><span class="line">main.(*Lottery).checkStatus 校验活动、场次是否正在进行...</span><br><span class="line">main.TimesDraw.checkParams 按抽奖次数抽奖类型:特殊参数校验...</span><br><span class="line">main.(*Lottery).checkTimesByAct 活动抽奖次数校验...</span><br><span class="line">main.(*Lottery).consumePointsByAct 活动是否需要消费积分...</span><br><span class="line">main.(*Lottery).checkTimesBySession 活动抽奖次数校验...</span><br><span class="line">main.(*Lottery).getPrizesBySession 获取场次奖品信息...</span><br><span class="line">main.TimesDraw.getPrizesByNode 1. 判断是该用户第几次抽奖...</span><br><span class="line">main.TimesDraw.getPrizesByNode 2. 获取对应node的奖品信息...</span><br><span class="line">main.TimesDraw.getPrizesByNode 3. 复写原所有奖品信息(抽取该node节点的奖品)...</span><br><span class="line">main.(*Lottery).drawPrizes 抽奖...</span><br><span class="line">main.(*Lottery).checkPrizesStock 奖品数量判断...</span><br><span class="line">main.(*Lottery).packagePrizeInfo 组装奖品信息...</span><br></pre></td></tr></table></figure><br><br>demo代码地址：<a href="https://github.com/TIGERB/easy-tips/blob/master/go/src/patterns/template/template.go" target="_blank" rel="noopener">https://github.com/TIGERB/easy-tips/blob/master/go/src/patterns/template/template.go</a><br><br>#### 代码demo2(利用golang的<code>合成复用</code>特性实现)<br><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Go设计模式实战系列</span></span><br><span class="line"><span class="comment">//模板模式</span></span><br><span class="line"><span class="comment">//@auhtor TIGERB&lt;https://github.com/TIGERB&gt;</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// ConstActTypeTime 按时间抽奖类型</span></span><br><span class="line">	ConstActTypeTime <span class="keyword">int32</span> = <span class="number">1</span></span><br><span class="line">	<span class="comment">// ConstActTypeTimes 按抽奖次数抽奖</span></span><br><span class="line">	ConstActTypeTimes <span class="keyword">int32</span> = <span class="number">2</span></span><br><span class="line">	<span class="comment">// ConstActTypeAmount 按数额范围区间抽奖</span></span><br><span class="line">	ConstActTypeAmount <span class="keyword">int32</span> = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context 上下文</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	ActInfo *ActInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActInfo 上下文</span></span><br><span class="line"><span class="keyword">type</span> ActInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 活动抽奖类型1: 按时间抽奖 2: 按抽奖次数抽奖 3:按数额范围区间抽奖</span></span><br><span class="line">	ActivityType <span class="keyword">int32</span></span><br><span class="line">	<span class="comment">// 其他字段略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BehaviorInterface 不同抽奖类型的行为差异的抽象接口</span></span><br><span class="line"><span class="keyword">type</span> BehaviorInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 其他参数校验(不同活动类型实现不同)</span></span><br><span class="line">	checkParams(ctx *Context) error</span><br><span class="line">	<span class="comment">// 获取node奖品信息(不同活动类型实现不同)</span></span><br><span class="line">	getPrizesByNode(ctx *Context) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TimeDraw 具体抽奖行为</span></span><br><span class="line"><span class="comment">// 按时间抽奖类型 比如红包雨</span></span><br><span class="line"><span class="keyword">type</span> TimeDraw <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用模板</span></span><br><span class="line">	Lottery</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkParams 其他参数校验(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw TimeDraw)</span> <span class="title">checkParams</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"按时间抽奖类型:特殊参数校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrizesByNode 获取node奖品信息(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw TimeDraw)</span> <span class="title">getPrizesByNode</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"do nothing(抽取该场次的奖品即可，无需其他逻辑)..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TimesDraw 具体抽奖行为</span></span><br><span class="line"><span class="comment">// 按抽奖次数抽奖类型 比如答题闯关</span></span><br><span class="line"><span class="keyword">type</span> TimesDraw <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用模板</span></span><br><span class="line">	Lottery</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkParams 其他参数校验(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw TimesDraw)</span> <span class="title">checkParams</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"按抽奖次数抽奖类型:特殊参数校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrizesByNode 获取node奖品信息(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw TimesDraw)</span> <span class="title">getPrizesByNode</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"1. 判断是该用户第几次抽奖..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"2. 获取对应node的奖品信息..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"3. 复写原所有奖品信息(抽取该node节点的奖品)..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AmountDraw 具体抽奖行为</span></span><br><span class="line"><span class="comment">// 按数额范围区间抽奖 比如订单金额刮奖</span></span><br><span class="line"><span class="keyword">type</span> AmountDraw <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用模板</span></span><br><span class="line">	Lottery</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkParams 其他参数校验(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw *AmountDraw)</span> <span class="title">checkParams</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"按数额范围区间抽奖:特殊参数校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrizesByNode 获取node奖品信息(不同活动类型实现不同)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(draw *AmountDraw)</span> <span class="title">getPrizesByNode</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"1. 判断属于哪个数额区间..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"2. 获取对应node的奖品信息..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"3. 复写原所有奖品信息(抽取该node节点的奖品)..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lottery 抽奖模板</span></span><br><span class="line"><span class="keyword">type</span> Lottery <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 不同抽奖类型的抽象行为</span></span><br><span class="line">	ConcreteBehavior BehaviorInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run 抽奖算法</span></span><br><span class="line"><span class="comment">// 稳定不变的算法步骤</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">Run</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 具体方法：校验活动编号(serial_no)是否存在、并获取活动信息</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkSerialNo(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：校验活动、场次是否正在进行</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkStatus(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ”抽象方法“：其他参数校验</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkParams(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：活动抽奖次数校验(同时扣减)</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkTimesByAct(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：活动是否需要消费积分</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.consumePointsByAct(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：场次抽奖次数校验(同时扣减)</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkTimesBySession(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：获取场次奖品信息</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.getPrizesBySession(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ”抽象方法“：获取node奖品信息</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.getPrizesByNode(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：抽奖</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.drawPrizes(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：奖品数量判断</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.checkPrizesStock(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具体方法：组装奖品信息</span></span><br><span class="line">	<span class="keyword">if</span> err = lottery.packagePrizeInfo(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkSerialNo 校验活动编号(serial_no)是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkSerialNo</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"校验活动编号(serial_no)是否存在、并获取活动信息..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkStatus 校验活动、场次是否正在进行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkStatus</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"校验活动、场次是否正在进行..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkParams 其他参数校验(不同活动类型实现不同)</span></span><br><span class="line"><span class="comment">// 不同场景变化的算法 转化为依赖抽象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkParams</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 实际依赖的接口的抽象方法</span></span><br><span class="line">	<span class="keyword">return</span> lottery.ConcreteBehavior.checkParams(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkTimesByAct 活动抽奖次数校验</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkTimesByAct</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"活动抽奖次数校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consumePointsByAct 活动是否需要消费积分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">consumePointsByAct</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"活动是否需要消费积分..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkTimesBySession 活动抽奖次数校验</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkTimesBySession</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"活动抽奖次数校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrizesBySession 获取场次奖品信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">getPrizesBySession</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取场次奖品信息..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrizesByNode 获取node奖品信息(不同活动类型实现不同)</span></span><br><span class="line"><span class="comment">// 不同场景变化的算法 转化为依赖抽象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">getPrizesByNode</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 实际依赖的接口的抽象方法</span></span><br><span class="line">	<span class="keyword">return</span> lottery.ConcreteBehavior.getPrizesByNode(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drawPrizes 抽奖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">drawPrizes</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"抽奖..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkPrizesStock 奖品数量判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">checkPrizesStock</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"奖品数量判断..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packagePrizeInfo 组装奖品信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lottery *Lottery)</span> <span class="title">packagePrizeInfo</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"组装奖品信息..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := &amp;Context&#123;</span><br><span class="line">	ActInfo: &amp;ActInfo&#123;</span><br><span class="line">	ActivityType: ConstActTypeAmount,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> ctx.ActInfo.ActivityType &#123;</span><br><span class="line">	<span class="keyword">case</span> ConstActTypeTime: <span class="comment">// 按时间抽奖类型</span></span><br><span class="line">	instance := &amp;TimeDraw&#123;&#125;</span><br><span class="line">	instance.ConcreteBehavior = instance</span><br><span class="line">	instance.Run(ctx)</span><br><span class="line">	<span class="keyword">case</span> ConstActTypeTimes: <span class="comment">// 按抽奖次数抽奖</span></span><br><span class="line">	instance := &amp;TimesDraw&#123;&#125;</span><br><span class="line">	instance.ConcreteBehavior = instance</span><br><span class="line">	instance.Run(ctx)</span><br><span class="line">	<span class="keyword">case</span> ConstActTypeAmount: <span class="comment">// 按数额范围区间抽奖</span></span><br><span class="line">	instance := &amp;AmountDraw&#123;&#125;</span><br><span class="line">	instance.ConcreteBehavior = instance</span><br><span class="line">	instance.Run(ctx)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">// 报错</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取正在运行的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFuncName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	pc := <span class="built_in">make</span>([]<span class="keyword">uintptr</span>, <span class="number">1</span>)</span><br><span class="line">	runtime.Callers(<span class="number">2</span>, pc)</span><br><span class="line">	f := runtime.FuncForPC(pc[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> f.Name()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>以下是代码执行结果:<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Running] go run &quot;.../easy-tips/go/src/patterns/template/templateOther.go&quot;</span><br><span class="line">main.(*Lottery).checkSerialNo 校验活动编号(serial_no)是否存在、并获取活动信息...</span><br><span class="line">main.(*Lottery).checkStatus 校验活动、场次是否正在进行...</span><br><span class="line">main.(*AmountDraw).checkParams 按数额范围区间抽奖:特殊参数校验...</span><br><span class="line">main.(*Lottery).checkTimesByAct 活动抽奖次数校验...</span><br><span class="line">main.(*Lottery).consumePointsByAct 活动是否需要消费积分...</span><br><span class="line">main.(*Lottery).checkTimesBySession 活动抽奖次数校验...</span><br><span class="line">main.(*Lottery).getPrizesBySession 获取场次奖品信息...</span><br><span class="line">main.(*AmountDraw).getPrizesByNode 1. 判断属于哪个数额区间...</span><br><span class="line">main.(*AmountDraw).getPrizesByNode 2. 获取对应node的奖品信息...</span><br><span class="line">main.(*AmountDraw).getPrizesByNode 3. 复写原所有奖品信息(抽取该node节点的奖品)...</span><br><span class="line">main.(*Lottery).drawPrizes 抽奖...</span><br><span class="line">main.(*Lottery).checkPrizesStock 奖品数量判断...</span><br><span class="line">main.(*Lottery).packagePrizeInfo 组装奖品信息...</span><br></pre></td></tr></table></figure><br><br>demo2代码地址：<a href="https://github.com/TIGERB/easy-tips/blob/master/go/src/patterns/template/templateOther.go" target="_blank" rel="noopener">https://github.com/TIGERB/easy-tips/blob/master/go/src/patterns/template/templateOther.go</a><br><br>## 结语<br><br>最后总结下，「模板模式」抽象过程的核心是把握<strong>不变</strong>与<strong>变</strong>：<br><br>- 不变：<code>Run</code>方法里的抽奖步骤 -&gt; <code>被继承复用</code><br>- 变：不同场景下 -&gt; <code>被具体实现</code><br>    + <code>checkParams</code>参数校验逻辑<br>    + <code>getPrizesByNode</code>获取该节点奖品的逻辑<br><br><br># 责任链模式<br><br>## 什么是「责任链模式」？<br><br>&gt; 首先把一系列业务按职责划分成不同的对象，接着把这一系列对象构成一个链，然后在这一系列对象中传递请求对象，直到被处理为止。<br><br>我们从概念中可以看出责任链模式有如下明显的优势：<br><br>- 按职责划分：解耦<br>- 对象链：逻辑清晰<br><br>但是有一点<code>直到被处理为止</code>，代表最终只会被一个实际的业务对象执行了实际的业务逻辑，明显适用的场景并不多。但是除此之外，上面的那两点优势还是让人很心动，所以，为了适用于目前所接触的绝大多数业务场景，把概念进行了简单的调整，如下：<br><br>&gt; 首先把一系列业务按职责划分成不同的对象，接着把这一系列对象构成一个链，直到“链路结束”为止。(结束：异常结束，或链路执行完毕结束)<br><br>简单的<code>直到“链路结束”为止</code>转换可以让我们把责任链模式适用于任何复杂的业务场景。<br><br>以下是责任链模式的具体优势：<br><br>- 直观：一眼可观的业务调用过程<br>- 无限扩展：可无限扩展的业务逻辑<br>- 高度封装：复杂业务代码依然高度封装<br>- 极易被修改：复杂业务代码下修改代码只需要专注对应的业务类(结构体)文件即可，以及极易被调整的业务执行顺序<br><br>## 什么真实业务场景可以用「责任链模式(改)」？<br><br>满足如下要求的场景:<br><br>&gt; 业务极度复杂的所有场景<br><br>任何杂乱无章的业务代码，都可以使用责任链模式(改)去重构、设计。<br><br>&gt; 我们有哪些真实业务场景可以用「责任链模式(改)」呢？<br><br>比如电商系统的下单接口，随着业务发展不断的发展，该接口会充斥着各种各样的业务逻辑。<br><br>## 怎么用「责任链模式(改)」？<br><br>关于怎么用，完全可以生搬硬套我总结的使用设计模式的四个步骤：<br><br>- 业务梳理<br>- 业务流程图<br>- 代码建模<br>- 代码demo<br><br>#### 业务梳理<br><br>步骤|逻辑<br>——-|——-<br>1|参数校验<br>2|获取地址信息<br>3|地址信息校验<br>4|获取购物车数据<br>5|获取商品库存信息<br>6|商品库存校验<br>7|获取优惠信息<br>8|获取运费信息<br>9|使用优惠信息<br>10|扣库存<br>11|清理购物车<br>12|写订单表<br>13|写订单商品表<br>14|写订单优惠信息表<br>XX|以及未来会增加的逻辑…<br><br>业务的不断发展变化的：<br><br>- 新的业务被增加<br>- 旧的业务被修改<br><br>比如增加的新的业务，订金预售：<br><br>- 在<code>4|获取购物车数据</code>后，需要校验商品参见订金预售活动的有效性等逻辑。<br>- 等等逻辑<br><br>&gt; 注：流程不一定完全准确<br><br>#### 业务流程图<br><br>我们通过梳理的文本业务流程得到了如下的业务流程图：<br><br><a href="http://cdn.tigerb.cn/20200327205310.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200327205310.png" alt=""></a><br><br>#### 代码建模<br><br>责任链模式主要类主要包含如下特性：<br><br>- 成员属性<br>    + <code>nextHandler</code>: 下一个等待被调用的对象实例 -&gt; 稳定不变的<br>- 成员方法<br>    + <code>SetNext</code>: 把下一个对象的实例绑定到当前对象的<code>nextHandler</code>属性上 -&gt; 稳定不变的<br>    + <code>Do</code>: 当前对象业务逻辑入口 -&gt; 变化的<br>    + <code>Run</code>: 调用当前对象的<code>Do</code>，<code>nextHandler</code>不为空则调用<code>nextHandler.Do</code> -&gt; 稳定不变的<br><br>套用到下单接口伪代码实现如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个父类(抽象类)：</span><br><span class="line"></span><br><span class="line">- 成员属性</span><br><span class="line">	+ `nextHandler`: 下一个等待被调用的对象实例</span><br><span class="line">- 成员方法</span><br><span class="line">	+ 实体方法`SetNext`: 实现把下一个对象的实例绑定到当前对象的`nextHandler`属性上</span><br><span class="line">	+ 抽象方法`Do`: 当前对象业务逻辑入口</span><br><span class="line">	+ 实体方法`Run`: 实现调用当前对象的`Do`，`nextHandler`不为空则调用`nextHandler.Do`</span><br><span class="line"></span><br><span class="line">子类一(参数校验)</span><br><span class="line">- 继承抽象类父类</span><br><span class="line">- 实现抽象方法`Do`：具体的参数校验逻辑</span><br><span class="line"></span><br><span class="line">子类二(获取地址信息)</span><br><span class="line">- 继承抽象类父类</span><br><span class="line">- 实现抽象方法`Do`：具体获取地址信息的逻辑</span><br><span class="line"></span><br><span class="line">子类三(获取购物车数据)</span><br><span class="line">- 继承抽象类父类</span><br><span class="line">- 实现抽象方法`Do`：具体获取购物车数据的逻辑</span><br><span class="line"></span><br><span class="line">......略</span><br><span class="line"></span><br><span class="line">子类X(以及未来会增加的逻辑)</span><br><span class="line">- 继承抽象类父类</span><br><span class="line">- 实现抽象方法`Do`：以及未来会增加的逻辑</span><br></pre></td></tr></table></figure><br><br>但是，golang里没有的继承的概念，要复用成员属性<code>nextHandler</code>、成员方法<code>SetNext</code>、成员方法<code>Run</code>怎么办呢？我们使用<code>合成复用</code>的特性变相达到“继承复用”的目的，如下：<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个接口(interface)：</span><br><span class="line"></span><br><span class="line">- 抽象方法`SetNext`: 待实现把下一个对象的实例绑定到当前对象的`nextHandler`属性上</span><br><span class="line">- 抽象方法`Do`: 待实现当前对象业务逻辑入口</span><br><span class="line">- 抽象方法`Run`: 待实现调用当前对象的`Do`，`nextHandler`不为空则调用`nextHandler.Do`</span><br><span class="line"></span><br><span class="line">一个基础结构体：</span><br><span class="line"></span><br><span class="line">- 成员属性</span><br><span class="line">	+ `nextHandler`: 下一个等待被调用的对象实例</span><br><span class="line">- 成员方法</span><br><span class="line">	+ 实体方法`SetNext`: 实现把下一个对象的实例绑定到当前对象的`nextHandler`属性上</span><br><span class="line">	+ 实体方法`Run`: 实现调用当前对象的`Do`，`nextHandler`不为空则调用`nextHandler.Do`</span><br><span class="line"></span><br><span class="line">子类一(参数校验)</span><br><span class="line">- 合成复用基础结构体</span><br><span class="line">- 实现抽象方法`Do`：具体的参数校验逻辑</span><br><span class="line"></span><br><span class="line">子类二(获取地址信息)</span><br><span class="line">- 合成复用基础结构体</span><br><span class="line">- 实现抽象方法`Do`：具体获取地址信息的逻辑</span><br><span class="line"></span><br><span class="line">子类三(获取购物车数据)</span><br><span class="line">- 合成复用基础结构体</span><br><span class="line">- 实现抽象方法`Do`：具体获取购物车数据的逻辑</span><br><span class="line"></span><br><span class="line">......略</span><br><span class="line"></span><br><span class="line">子类X(以及未来会增加的逻辑)</span><br><span class="line">- 合成复用基础结构体</span><br><span class="line">- 实现抽象方法`Do`：以及未来会增加的逻辑</span><br></pre></td></tr></table></figure><br><br>同时得到了我们的UML图：<br><br><a href="http://cdn.tigerb.cn/20200328220913.jpg" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200328220913.jpg" alt=""></a><br><br>#### 代码demo<br><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------</span></span><br><span class="line"><span class="comment">//Go设计模式实战系列</span></span><br><span class="line"><span class="comment">//责任链模式</span></span><br><span class="line"><span class="comment">//@auhtor TIGERB&lt;https://github.com/TIGERB&gt;</span></span><br><span class="line"><span class="comment">//---------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context Context</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler 处理</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 自身的业务</span></span><br><span class="line">	Do(c *Context) error</span><br><span class="line">	<span class="comment">// 设置下一个对象</span></span><br><span class="line">	SetNext(h Handler) Handler</span><br><span class="line">	<span class="comment">// 执行</span></span><br><span class="line">	Run(c *Context) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next 抽象出来的 可被合成复用的结构体</span></span><br><span class="line"><span class="keyword">type</span> Next <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 下一个对象</span></span><br><span class="line">	nextHandler Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetNext 实现好的 可被复用的SetNext方法</span></span><br><span class="line"><span class="comment">// 返回值是下一个对象 方便写成链式代码优雅</span></span><br><span class="line"><span class="comment">// 例如 nullHandler.SetNext(argumentsHandler).SetNext(signHandler).SetNext(frequentHandler)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Next)</span> <span class="title">SetNext</span><span class="params">(h Handler)</span> <span class="title">Handler</span></span> &#123;</span><br><span class="line">	n.nextHandler = h</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run 执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Next)</span> <span class="title">Run</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 由于go无继承的概念 这里无法执行当前handler的Do</span></span><br><span class="line">	<span class="comment">// n.Do(c)</span></span><br><span class="line">	<span class="keyword">if</span> n.nextHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 合成复用下的变种</span></span><br><span class="line">		<span class="comment">// 执行下一个handler的Do</span></span><br><span class="line">		<span class="keyword">if</span> err = (n.nextHandler).Do(c); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 执行下一个handler的Run</span></span><br><span class="line">		<span class="keyword">return</span> (n.nextHandler).Run(c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NullHandler 空Handler</span></span><br><span class="line"><span class="comment">// 由于go无继承的概念 作为链式调用的第一个载体 设置实际的下一个对象</span></span><br><span class="line"><span class="keyword">type</span> NullHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next的`nextHandler`成员属性、`SetNext`成员方法、`Run`成员方法</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 空Handler的Do</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *NullHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 空Handler 这里什么也不做 只是载体 do nothing...</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArgumentsHandler 校验参数的handler</span></span><br><span class="line"><span class="keyword">type</span> ArgumentsHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ArgumentsHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"校验参数成功..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddressInfoHandler 地址信息handler</span></span><br><span class="line"><span class="keyword">type</span> AddressInfoHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *AddressInfoHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取地址信息..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"地址信息校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CartInfoHandler 获取购物车数据handler</span></span><br><span class="line"><span class="keyword">type</span> CartInfoHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CartInfoHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取购物车数据..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StockInfoHandler 商品库存handler</span></span><br><span class="line"><span class="keyword">type</span> StockInfoHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *StockInfoHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取商品库存信息..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"商品库存校验..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PromotionInfoHandler 获取优惠信息handler</span></span><br><span class="line"><span class="keyword">type</span> PromotionInfoHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *PromotionInfoHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取优惠信息..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShipmentInfoHandler 获取运费信息handler</span></span><br><span class="line"><span class="keyword">type</span> ShipmentInfoHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ShipmentInfoHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取运费信息..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PromotionUseHandler 使用优惠信息handler</span></span><br><span class="line"><span class="keyword">type</span> PromotionUseHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *PromotionUseHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"使用优惠信息..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StockSubtractHandler 库存操作handler</span></span><br><span class="line"><span class="keyword">type</span> StockSubtractHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *StockSubtractHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"扣库存..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CartDelHandler 清理购物车handler</span></span><br><span class="line"><span class="keyword">type</span> CartDelHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CartDelHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"清理购物车..."</span>)</span><br><span class="line">	<span class="comment">// err = fmt.Errorf("CartDelHandler.Do fail")</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DBTableOrderHandler 写订单表handler</span></span><br><span class="line"><span class="keyword">type</span> DBTableOrderHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *DBTableOrderHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"写订单表..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DBTableOrderSkusHandler 写订单商品表handler</span></span><br><span class="line"><span class="keyword">type</span> DBTableOrderSkusHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *DBTableOrderSkusHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"写订单商品表..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DBTableOrderPromotionsHandler 写订单优惠信息表handler</span></span><br><span class="line"><span class="keyword">type</span> DBTableOrderPromotionsHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用Next</span></span><br><span class="line">	Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 校验参数的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *DBTableOrderPromotionsHandler)</span> <span class="title">Do</span><span class="params">(c *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"写订单优惠信息表..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取正在运行的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFuncName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	pc := <span class="built_in">make</span>([]<span class="keyword">uintptr</span>, <span class="number">1</span>)</span><br><span class="line">	runtime.Callers(<span class="number">2</span>, pc)</span><br><span class="line">	f := runtime.FuncForPC(pc[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> f.Name()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化空handler</span></span><br><span class="line">	nullHandler := &amp;NullHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 链式调用 代码是不是很优雅</span></span><br><span class="line">	<span class="comment">// 很明显的链 逻辑关系一览无余</span></span><br><span class="line">	nullHandler.SetNext(&amp;ArgumentsHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;AddressInfoHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;CartInfoHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;StockInfoHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;PromotionInfoHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;ShipmentInfoHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;PromotionUseHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;StockSubtractHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;CartDelHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;DBTableOrderHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;DBTableOrderSkusHandler&#123;&#125;).</span><br><span class="line">		SetNext(&amp;DBTableOrderPromotionsHandler&#123;&#125;)</span><br><span class="line">		<span class="comment">//无限扩展代码...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始执行业务</span></span><br><span class="line">	<span class="keyword">if</span> err := nullHandler.Run(&amp;Context&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 异常</span></span><br><span class="line">		fmt.Println(<span class="string">"Fail | Error:"</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 成功</span></span><br><span class="line">	fmt.Println(<span class="string">"Success"</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>代码运行结果：<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Running] go run &quot;../easy-tips/go/src/patterns/responsibility/responsibility-order-submit.go&quot;</span><br><span class="line">main.(*ArgumentsHandler).Do 校验参数成功...</span><br><span class="line">main.(*AddressInfoHandler).Do 获取地址信息...</span><br><span class="line">main.(*AddressInfoHandler).Do 地址信息校验...</span><br><span class="line">main.(*CartInfoHandler).Do 获取购物车数据...</span><br><span class="line">main.(*StockInfoHandler).Do 获取商品库存信息...</span><br><span class="line">main.(*StockInfoHandler).Do 商品库存校验...</span><br><span class="line">main.(*PromotionInfoHandler).Do 获取优惠信息...</span><br><span class="line">main.(*ShipmentInfoHandler).Do 获取运费信息...</span><br><span class="line">main.(*PromotionUseHandler).Do 使用优惠信息...</span><br><span class="line">main.(*StockSubtractHandler).Do 扣库存...</span><br><span class="line">main.(*CartDelHandler).Do 清理购物车...</span><br><span class="line">main.(*DBTableOrderHandler).Do 写订单表...</span><br><span class="line">main.(*DBTableOrderSkusHandler).Do 写订单商品表...</span><br><span class="line">main.(*DBTableOrderPromotionsHandler).Do 写订单优惠信息表...</span><br><span class="line">Success</span><br></pre></td></tr></table></figure><br><br>## 结语<br><br>最后总结下，「责任链模式(改)」抽象过程的核心是：<br><br>- 按职责划分：业务逻辑归类，收敛的过程。<br>- 对象链：把收敛之后的业务对象构成对象链，依次被执行。<br><br># 组合模式<br><br>## 什么是「组合模式」？<br><br>&gt; 一个具有层级关系的对象由一系列拥有父子关系的对象通过树形结构组成。<br><br>组合模式的优势：<br><br>- 所见即所码：你所看见的代码结构就是业务真实的层级关系，比如Ui界面你真实看到的那样。<br>- 高度封装：单一职责。<br>- 可复用：不同业务场景，相同的组件可被重复使用。<br><br>## 什么真实业务场景可以用「组合模式」？<br><br>满足如下要求的所有场景:<br><br>&gt; Get请求获取页面数据的所有接口<br><br>前端大行组件化的当今，我们在写后端接口代码的时候还是按照业务思路一头写到尾吗？我们是否可以思索，「后端接口业务代码如何可以简单快速组件化？」，答案是肯定的，这就是「组合模式」的作用。<br><br>我们利用「组合模式」的定义和前端模块的划分去构建后端业务代码结构：<br><br>- 前端单个模块 -&gt; 对应后端：具体单个类 -&gt; 封装的过程<br>- 前端模块父子组件 -&gt;  对应后端：父类内部持有多个子类(非继承关系，合成复用关系) -&gt; 父子关系的树形结构<br><br>&gt; 我们有哪些真实业务场景可以用「组合模式」呢？<br><br>比如我们以“复杂的订单结算页面”为例，下面是某东的订单结算页面：<br><br></p><p align="center"><br>  <a href="http://cdn.tigerb.cn/20200331124724.jpeg" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200331124724.jpeg" style="width:38%"></a><br></p>

<p>从页面的展示形式上，可以看出：</p>
<ul>
<li>页面由多个模块构成，比如：<ul>
<li>地址模块</li>
<li>支付方式模块</li>
<li>店铺模块</li>
<li>发票模块</li>
<li>优惠券模块</li>
<li>某豆模块</li>
<li>礼品卡模块</li>
<li>订单详细金额模块</li>
</ul>
</li>
<li>单个模块可以由多个子模块构成<ul>
<li>店铺模块，又由如下模块构成：<ul>
<li>商品模块</li>
<li>售后模块</li>
<li>优惠模块</li>
<li>物流模块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="怎么用「组合模式」？"><a href="#怎么用「组合模式」？" class="headerlink" title="怎么用「组合模式」？"></a>怎么用「组合模式」？</h2><p>关于怎么用，完全可以生搬硬套我总结的使用设计模式的四个步骤：</p>
<ul>
<li>业务梳理</li>
<li>业务流程图</li>
<li>代码建模</li>
<li>代码demo</li>
</ul>
<h4 id="业务梳理"><a href="#业务梳理" class="headerlink" title="业务梳理"></a>业务梳理</h4><p>按照如上某东的订单结算页面的示例，我们得到了如下的订单结算页面模块组成图：</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200329222214.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200329222214.png" style="width:46%"></a><br></p>

<blockquote>
<p>注：模块不一定完全准确</p>
</blockquote>
<h4 id="代码建模"><a href="#代码建模" class="headerlink" title="代码建模"></a>代码建模</h4><p>责任链模式主要类主要包含如下特性：</p>
<ul>
<li>成员属性<ul>
<li><code>ChildComponents</code>: 子组件列表 -&gt; 稳定不变的</li>
</ul>
</li>
<li>成员方法<ul>
<li><code>Mount</code>: 添加一个子组件 -&gt; 稳定不变的</li>
<li><code>Remove</code>: 移除一个子组件 -&gt; 稳定不变的</li>
<li><code>Do</code>: 执行组件&amp;子组件 -&gt; 变化的</li>
</ul>
</li>
</ul>
<p>套用到订单结算页面信息接口伪代码实现如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个父类(抽象类)：</span><br><span class="line">- 成员属性</span><br><span class="line">	+ `ChildComponents`: 子组件列表</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Mount`: 实现添加一个子组件</span><br><span class="line">	+ `Remove`: 实现移除一个子组件</span><br><span class="line">	+ `Do`: 抽象方法</span><br><span class="line"></span><br><span class="line">组件一，订单结算页面组件类(继承父类、看成一个大的组件)： </span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件二，地址组件(继承父类)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件三，支付方式组件(继承父类)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件四，店铺组件(继承父类)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件五，商品组件(继承父类)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件六，优惠信息组件(继承父类)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件七，物流组件(继承父类)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件八，发票组件(继承父类)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件九，优惠券组件(继承父类)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件十，礼品卡组件(继承父类)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件十一，订单金额详细信息组件(继承父类)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line">组件十二，售后组件(继承父类，未来扩展的组件)：</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br></pre></td></tr></table></figure></p>
<p>但是，golang里没有的继承的概念，要复用成员属性<code>ChildComponents</code>、成员方法<code>Mount</code>、成员方法<code>Remove</code>怎么办呢？我们使用<code>合成复用</code>的特性变相达到“继承复用”的目的，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个接口(interface)：</span><br><span class="line">+ 抽象方法`Mount`: 添加一个子组件</span><br><span class="line">+ 抽象方法`Remove`: 移除一个子组件</span><br><span class="line">+ 抽象方法`Do`: 执行组件&amp;子组件</span><br><span class="line"></span><br><span class="line">一个基础结构体`BaseComponent`：</span><br><span class="line">- 成员属性</span><br><span class="line">	+ `ChildComponents`: 子组件列表</span><br><span class="line">- 成员方法</span><br><span class="line">	+ 实体方法`Mount`: 添加一个子组件</span><br><span class="line">	+ 实体方法`Remove`: 移除一个子组件</span><br><span class="line">	+ 实体方法`ChildsDo`: 执行子组件</span><br><span class="line"></span><br><span class="line">组件一，订单结算页面组件类： </span><br><span class="line">- 合成复用基础结构体`BaseComponent` </span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件二，地址组件：</span><br><span class="line">- 合成复用基础结构体`BaseComponent` </span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">组件三，支付方式组件：</span><br><span class="line">- 合成复用基础结构体`BaseComponent` </span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br><span class="line"></span><br><span class="line">...略</span><br><span class="line"></span><br><span class="line">组件十一，订单金额详细信息组件：</span><br><span class="line">- 合成复用基础结构体`BaseComponent` </span><br><span class="line">- 成员方法</span><br><span class="line">	+ `Do`: 执行当前组件的逻辑，执行子组件的逻辑</span><br></pre></td></tr></table></figure>
<p>同时得到了我们的UML图：</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200403125814.jpg" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200403125814.jpg" style="width:100%"></a><br></p>

<h4 id="代码demo"><a href="#代码demo" class="headerlink" title="代码demo"></a>代码demo</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Go设计模式实战系列</span></span><br><span class="line"><span class="comment">//组合模式</span></span><br><span class="line"><span class="comment">//@auhtor TIGERB&lt;https://github.com/TIGERB&gt;</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Context 上下文</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Component 组件接口</span></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 添加一个子组件</span></span><br><span class="line">	Mount(c Component, components ...Component) error</span><br><span class="line">	<span class="comment">// 移除一个子组件</span></span><br><span class="line">	Remove(c Component) error</span><br><span class="line">	<span class="comment">// 执行组件&amp;子组件</span></span><br><span class="line">	Do(ctx *Context) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BaseComponent 基础组件</span></span><br><span class="line"><span class="comment">// 实现Add:添加一个子组件</span></span><br><span class="line"><span class="comment">// 实现Remove:移除一个子组件</span></span><br><span class="line"><span class="keyword">type</span> BaseComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 子组件列表</span></span><br><span class="line">	ChildComponents []Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mount 挂载一个子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">Mount</span><span class="params">(c Component, components ...Component)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents, c)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(components) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents, components...)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 移除一个子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">Remove</span><span class="params">(c Component)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(bc.ChildComponents) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> c == childComponent &#123;</span><br><span class="line">			fmt.Println(runFuncName(), <span class="string">"移除:"</span>, reflect.TypeOf(childComponent))</span><br><span class="line">			bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents[:k], bc.ChildComponents[k+<span class="number">1</span>:]...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// do nothing</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChildsDo 执行子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">ChildsDo</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	<span class="keyword">for</span> _, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> err = childComponent.Do(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CheckoutPageComponent 订单结算页面组件</span></span><br><span class="line"><span class="keyword">type</span> CheckoutPageComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *CheckoutPageComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"订单结算页面组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddressComponent 地址组件</span></span><br><span class="line"><span class="keyword">type</span> AddressComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *AddressComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"地址组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PayMethodComponent 支付方式组件</span></span><br><span class="line"><span class="keyword">type</span> PayMethodComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *PayMethodComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"支付方式组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StoreComponent 店铺组件</span></span><br><span class="line"><span class="keyword">type</span> StoreComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *StoreComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"店铺组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SkuComponent 商品组件</span></span><br><span class="line"><span class="keyword">type</span> SkuComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *SkuComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"商品组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PromotionComponent 优惠信息组件</span></span><br><span class="line"><span class="keyword">type</span> PromotionComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *PromotionComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"优惠信息组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExpressComponent 物流组件</span></span><br><span class="line"><span class="keyword">type</span> ExpressComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *ExpressComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"物流组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AftersaleComponent 售后组件</span></span><br><span class="line"><span class="keyword">type</span> AftersaleComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *AftersaleComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"售后组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InvoiceComponent 发票组件</span></span><br><span class="line"><span class="keyword">type</span> InvoiceComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *InvoiceComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"发票组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CouponComponent 优惠券组件</span></span><br><span class="line"><span class="keyword">type</span> CouponComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *CouponComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"优惠券组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GiftCardComponent 礼品卡组件</span></span><br><span class="line"><span class="keyword">type</span> GiftCardComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *GiftCardComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"礼品卡组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderComponent 订单金额详细信息组件</span></span><br><span class="line"><span class="keyword">type</span> OrderComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行组件&amp;子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *OrderComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"订单金额详细信息组件..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	bc.ChildsDo(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化订单结算页面 这个大组件</span></span><br><span class="line">	checkoutPage := &amp;CheckoutPageComponent&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂载子组件</span></span><br><span class="line">	storeComponent := &amp;StoreComponent&#123;&#125;</span><br><span class="line">	skuComponent := &amp;SkuComponent&#123;&#125;</span><br><span class="line">	skuComponent.Mount(</span><br><span class="line">		&amp;PromotionComponent&#123;&#125;,</span><br><span class="line">		&amp;AftersaleComponent&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line">	storeComponent.Mount(</span><br><span class="line">		skuComponent,</span><br><span class="line">		&amp;ExpressComponent&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂载组件</span></span><br><span class="line">	checkoutPage.Mount(</span><br><span class="line">		&amp;AddressComponent&#123;&#125;,</span><br><span class="line">		&amp;PayMethodComponent&#123;&#125;,</span><br><span class="line">		storeComponent,</span><br><span class="line">		&amp;InvoiceComponent&#123;&#125;,</span><br><span class="line">		&amp;CouponComponent&#123;&#125;,</span><br><span class="line">		&amp;GiftCardComponent&#123;&#125;,</span><br><span class="line">		&amp;OrderComponent&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移除组件测试</span></span><br><span class="line">	<span class="comment">// checkoutPage.Remove(storeComponent)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始构建页面组件数据</span></span><br><span class="line">	checkoutPage.Do(&amp;Context&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取正在运行的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFuncName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	pc := <span class="built_in">make</span>([]<span class="keyword">uintptr</span>, <span class="number">1</span>)</span><br><span class="line">	runtime.Callers(<span class="number">2</span>, pc)</span><br><span class="line">	f := runtime.FuncForPC(pc[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> f.Name()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Running] go run &quot;../easy-tips/go/src/patterns/composite/composite.go&quot;</span><br><span class="line">main.(*CheckoutPageComponent).Do 订单结算页面组件...</span><br><span class="line">main.(*AddressComponent).Do 地址组件...</span><br><span class="line">main.(*PayMethodComponent).Do 支付方式组件...</span><br><span class="line">main.(*StoreComponent).Do 店铺组件...</span><br><span class="line">main.(*SkuComponent).Do 商品组件...</span><br><span class="line">main.(*PromotionComponent).Do 优惠信息组件...</span><br><span class="line">main.(*AftersaleComponent).Do 售后组件...</span><br><span class="line">main.(*ExpressComponent).Do 物流组件...</span><br><span class="line">main.(*InvoiceComponent).Do 发票组件...</span><br><span class="line">main.(*CouponComponent).Do 优惠券组件...</span><br><span class="line">main.(*GiftCardComponent).Do 礼品卡组件...</span><br><span class="line">main.(*OrderComponent).Do 订单金额详细信息组件...</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后总结下，「组合模式」抽象过程的核心是：</p>
<ul>
<li>按模块划分：业务逻辑归类，收敛的过程。</li>
<li>父子关系(树)：把收敛之后的业务对象按父子关系绑定，依次被执行。</li>
</ul>
<p>与「责任链模式」的区别：</p>
<ul>
<li>责任链模式: 链表</li>
<li>组合模式：树</li>
</ul>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="什么是「观察者模式」？"><a href="#什么是「观察者模式」？" class="headerlink" title="什么是「观察者模式」？"></a>什么是「观察者模式」？</h2><blockquote>
<p>观察者观察被观察者，被观察者通知观察者</p>
</blockquote>
<p>我们用“订阅通知”翻译下「观察者模式」的概念，结果：</p>
<blockquote>
<p>“订阅者订阅主题，主题通知订阅者”</p>
</blockquote>
<p>是不是容易理解多了，我们再来拆解下这句话，得到：</p>
<ul>
<li>两个对象<ul>
<li>被观察者 -&gt; 主题</li>
<li>观察者 -&gt; 订阅者</li>
</ul>
</li>
<li>两个动作<ul>
<li>订阅 -&gt; 订阅者<strong>订阅</strong>主题</li>
<li>通知 -&gt; 主题发生变动<strong>通知</strong>订阅者</li>
</ul>
</li>
</ul>
<p>观察者模式的优势：</p>
<ul>
<li>高内聚 -&gt; 不同业务代码变动互不影响</li>
<li>可复用 -&gt; 新的业务(就是新的订阅者)订阅不同接口(主题，就是这里的接口)</li>
<li>极易扩展 -&gt; 新增接口(就是新增主题)；新增业务(就是新增订阅者)；</li>
</ul>
<p>其实说白了，就是分布式架构中使用消息机制MQ解耦业务的优势，是不是这么一想很容易理解了。</p>
<h2 id="什么真实业务场景可以用「观察者模式」？"><a href="#什么真实业务场景可以用「观察者模式」？" class="headerlink" title="什么真实业务场景可以用「观察者模式」？"></a>什么真实业务场景可以用「观察者模式」？</h2><blockquote>
<p>所有发生变更，需要通知的业务场景</p>
</blockquote>
<p>详细说：只要发生了某些变化，需要通知依赖了这些变化的具体事物的业务场景。</p>
<blockquote>
<p>我们有哪些真实业务场景可以用「观察者模式」呢？</p>
</blockquote>
<p>比如，订单逆向流，也就是订单成立之后的各种取消操作(本文不讨论售后)，主要有如下取消类型：</p>
<table>
<thead>
<tr>
<th>订单取消类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>未支付取消订单</td>
</tr>
<tr>
<td>超时关单</td>
</tr>
<tr>
<td>已支付取消订单</td>
</tr>
<tr>
<td>取消发货单</td>
</tr>
<tr>
<td>拒收</td>
</tr>
</tbody>
</table>
<p>在触发这些<strong>取消操作</strong>都要进行各种各样的子操作，显而易见不同的<strong>取消操作</strong>所涉及的子操作是存在交集的。其次，已支付取消订单的子操作应该是所有订单取消类型最全的，其他类型的复用代码即可，除了分装成函数片段，还有什么更好的封装方式吗？答案：「观察者模式」。</p>
<p>接着我们来分析下订单逆向流业务中的<strong>变</strong>与<strong>不变</strong>：</p>
<ul>
<li>变<ul>
<li>新增取消类型</li>
<li>新增子操作</li>
<li>修改某个子操作的逻辑</li>
<li>取消类型和子操作的对应关系</li>
</ul>
</li>
<li>不变<ul>
<li>已存在的取消类型</li>
<li>已存在的子操作(在外界看来)</li>
</ul>
</li>
</ul>
<h2 id="怎么用「观察者模式」？"><a href="#怎么用「观察者模式」？" class="headerlink" title="怎么用「观察者模式」？"></a>怎么用「观察者模式」？</h2><p>关于怎么用，完全可以生搬硬套我总结的使用设计模式的四个步骤：</p>
<ul>
<li>业务梳理</li>
<li>业务流程图</li>
<li>代码建模</li>
<li>代码demo</li>
</ul>
<h4 id="业务梳理-1"><a href="#业务梳理-1" class="headerlink" title="业务梳理"></a>业务梳理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：本文于单体架构背景探讨业务的实现过程，简单容易理解。</span><br></pre></td></tr></table></figure>
<p>第一步，梳理出所有存在的的逆向业务的子操作，如下：</p>
<table>
<thead>
<tr>
<th>所有子操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>修改订单状态</td>
</tr>
<tr>
<td>记录订单状态变更日志</td>
</tr>
<tr>
<td>退优惠券</td>
</tr>
<tr>
<td>还优惠活动资格</td>
</tr>
<tr>
<td>还库存</td>
</tr>
<tr>
<td>还礼品卡</td>
</tr>
<tr>
<td>退钱包余额</td>
</tr>
<tr>
<td>修改发货单状态</td>
</tr>
<tr>
<td>记录发货单状态变更日志</td>
</tr>
<tr>
<td>生成退款单</td>
</tr>
<tr>
<td>生成发票-红票</td>
</tr>
<tr>
<td>发邮件</td>
</tr>
<tr>
<td>发短信</td>
</tr>
<tr>
<td>发微信消息</td>
</tr>
</tbody>
</table>
<p>第二步，找到不同订单取消类型和这些子操作的关系，如下：</p>
<table>
<thead>
<tr>
<th>订单取消类型(“主题”)(被观察者)</th>
<th>子操作(“订阅者”)(观察者)</th>
</tr>
</thead>
<tbody>
<tr>
<td>取消未支付订单</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>修改订单状态</td>
</tr>
<tr>
<td>-</td>
<td>记录订单状态变更日志</td>
</tr>
<tr>
<td>-</td>
<td>退优惠券</td>
</tr>
<tr>
<td>-</td>
<td>还优惠活动资格</td>
</tr>
<tr>
<td>-</td>
<td>还库存</td>
</tr>
<tr>
<td>超时关单</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>修改订单状态</td>
</tr>
<tr>
<td>-</td>
<td>记录订单状态变更日志</td>
</tr>
<tr>
<td>-</td>
<td>退优惠券</td>
</tr>
<tr>
<td>-</td>
<td>还优惠活动资格</td>
</tr>
<tr>
<td>-</td>
<td>还库存</td>
</tr>
<tr>
<td>-</td>
<td>发邮件</td>
</tr>
<tr>
<td>-</td>
<td>发短信</td>
</tr>
<tr>
<td>-</td>
<td>发微信消息</td>
</tr>
<tr>
<td>已支付取消订单(未生成发货单)</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>修改订单状态</td>
</tr>
<tr>
<td>-</td>
<td>记录订单状态变更日志</td>
</tr>
<tr>
<td>-</td>
<td>还优惠活动资格(看情况)</td>
</tr>
<tr>
<td>-</td>
<td>还库存</td>
</tr>
<tr>
<td>-</td>
<td>还礼品卡</td>
</tr>
<tr>
<td>-</td>
<td>退钱包余额</td>
</tr>
<tr>
<td>-</td>
<td>生成退款单</td>
</tr>
<tr>
<td>-</td>
<td>生成发票-红票</td>
</tr>
<tr>
<td>-</td>
<td>发邮件</td>
</tr>
<tr>
<td>-</td>
<td>发短信</td>
</tr>
<tr>
<td>-</td>
<td>发微信消息</td>
</tr>
<tr>
<td>取消发货单(未发货)</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>修改订单状态</td>
</tr>
<tr>
<td>-</td>
<td>记录订单状态变更日志</td>
</tr>
<tr>
<td>-</td>
<td>修改发货单状态</td>
</tr>
<tr>
<td>-</td>
<td>记录发货单状态变更日志</td>
</tr>
<tr>
<td>-</td>
<td>还库存</td>
</tr>
<tr>
<td>-</td>
<td>还礼品卡</td>
</tr>
<tr>
<td>-</td>
<td>退钱包余额</td>
</tr>
<tr>
<td>-</td>
<td>生成退款单</td>
</tr>
<tr>
<td>-</td>
<td>生成发票-红票</td>
</tr>
<tr>
<td>-</td>
<td>发邮件</td>
</tr>
<tr>
<td>-</td>
<td>发短信</td>
</tr>
<tr>
<td>-</td>
<td>发微信消息</td>
</tr>
<tr>
<td>拒收</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>修改订单状态</td>
</tr>
<tr>
<td>-</td>
<td>记录订单状态变更日志</td>
</tr>
<tr>
<td>-</td>
<td>修改发货单状态</td>
</tr>
<tr>
<td>-</td>
<td>记录发货单状态变更日志</td>
</tr>
<tr>
<td>-</td>
<td>还库存</td>
</tr>
<tr>
<td>-</td>
<td>还礼品卡</td>
</tr>
<tr>
<td>-</td>
<td>退钱包余额</td>
</tr>
<tr>
<td>-</td>
<td>生成退款单</td>
</tr>
<tr>
<td>-</td>
<td>生成发票-红票</td>
</tr>
<tr>
<td>-</td>
<td>发邮件</td>
</tr>
<tr>
<td>-</td>
<td>发短信</td>
</tr>
<tr>
<td>-</td>
<td>发微信消息</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：流程不一定完全准确、全面。</p>
</blockquote>
<p>结论：</p>
<ul>
<li>不同的订单取消类型的子操作存在交集，子操作可被复用。</li>
<li>子操作可被看作“订阅者”(也就是观察者)</li>
<li>订单取消类型可被看作是“主题”(也就是被观察者)</li>
<li>不同子操作(“订阅者”)(观察者)<strong>订阅</strong>订单取消类型(“主题”)(被观察者)</li>
<li>订单取消类型(“主题”)(被观察者)<strong>通知</strong>子操作(“订阅者”)(观察者)</li>
</ul>
<h4 id="业务流程图"><a href="#业务流程图" class="headerlink" title="业务流程图"></a>业务流程图</h4><p>我们通过梳理的文本业务流程得到了如下的业务流程图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：本文于单体架构背景探讨业务的实现过程，简单容易理解。</span><br></pre></td></tr></table></figure>
<p><a href="http://cdn.tigerb.cn/20200410131427.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200410131427.png" alt=""></a></p>
<h4 id="代码建模-1"><a href="#代码建模-1" class="headerlink" title="代码建模"></a>代码建模</h4><p>「观察者模式」的核心是两个接口：</p>
<ul>
<li>“主题”(被观察者)接口<code>Observable</code><ul>
<li>抽象方法<code>Attach</code>: 增加“订阅者”</li>
<li>抽象方法<code>Detach</code>: 删除“订阅者”</li>
<li>抽象方法<code>Notify</code>: 通知“订阅者”</li>
</ul>
</li>
<li>“订阅者”(观察者)接口<code>ObserverInterface</code><ul>
<li>抽象方法<code>Do</code>: 自身的业务</li>
</ul>
</li>
</ul>
<p>订单逆向流的业务下，我们需要实现这两个接口:</p>
<ul>
<li>具体订单取消的动作实现“主题”接口<code>Observable</code></li>
<li>子逻辑实现“订阅者”接口<code>ObserverInterface</code></li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ------------这里实现一个具体的“主题”------------</span><br><span class="line"></span><br><span class="line">具体订单取消的动作实现“主题”(被观察者)接口`Observable`。得到一个具体的“主题”:</span><br><span class="line"></span><br><span class="line">- 订单取消的动作的“主题”结构体`ObservableConcrete`</span><br><span class="line">    +  成员属性`observerList []ObserverInterface`:订阅者列表</span><br><span class="line">    +  具体方法`Attach`: 增加子逻辑</span><br><span class="line">    +  具体方法`Detach`: 删除子逻辑</span><br><span class="line">    +  具体方法`Notify`: 通知子逻辑</span><br><span class="line"></span><br><span class="line">// ------------这里实现所有具体的“订阅者”------------</span><br><span class="line"></span><br><span class="line">子逻辑实现“订阅者”接口`ObserverInterface`:</span><br><span class="line"></span><br><span class="line">- 具体“订阅者”也就是子逻辑`OrderStatus`</span><br><span class="line">    +  实现方法`Do`: 修改订单状态</span><br><span class="line">- 具体“订阅者”也就是子逻辑`OrderStatusLog`</span><br><span class="line">    +  实现方法`Do`: 记录订单状态变更日志</span><br><span class="line">- 具体“订阅者”也就是子逻辑`CouponRefund`</span><br><span class="line">    +  实现方法`Do`: 退优惠券</span><br><span class="line">- 具体“订阅者”也就是子逻辑`PromotionRefund`</span><br><span class="line">    +  实现方法`Do`: 还优惠活动资格</span><br><span class="line">- 具体“订阅者”也就是子逻辑`StockRefund`</span><br><span class="line">    +  实现方法`Do`: 还库存</span><br><span class="line">- 具体“订阅者”也就是子逻辑`GiftCardRefund`</span><br><span class="line">    +  实现方法`Do`: 还礼品卡</span><br><span class="line">- 具体“订阅者”也就是子逻辑`WalletRefund`</span><br><span class="line">    +  实现方法`Do`: 退钱包余额</span><br><span class="line">- 具体“订阅者”也就是子逻辑`DeliverBillStatus`</span><br><span class="line">    +  实现方法`Do`: 修改发货单状态</span><br><span class="line">- 具体“订阅者”也就是子逻辑`DeliverBillStatusLog`</span><br><span class="line">    +  实现方法`Do`: 记录发货单状态变更日志</span><br><span class="line">- 具体“订阅者”也就是子逻辑`Refund`</span><br><span class="line">    +  实现方法`Do`: 生成退款单</span><br><span class="line">- 具体“订阅者”也就是子逻辑`Invoice`</span><br><span class="line">    +  实现方法`Do`: 生成发票-红票</span><br><span class="line">- 具体“订阅者”也就是子逻辑`Email`</span><br><span class="line">    +  实现方法`Do`: 发邮件</span><br><span class="line">- 具体“订阅者”也就是子逻辑`Sms`</span><br><span class="line">    +  实现方法`Do`: 发短信</span><br><span class="line">- 具体“订阅者”也就是子逻辑`WechatNotify`</span><br><span class="line">    +  实现方法`Do`: 发微信消息</span><br></pre></td></tr></table></figure>
<p>同时得到了我们的UML图：</p>
<p><a href="http://cdn.tigerb.cn/20200411181215.jpg" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200411181215.jpg" alt=""></a></p>
<h4 id="代码demo-1"><a href="#代码demo-1" class="headerlink" title="代码demo"></a>代码demo</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Go设计模式实战系列</span></span><br><span class="line"><span class="comment">//观察者模式</span></span><br><span class="line"><span class="comment">//@auhtor TIGERB&lt;https://github.com/TIGERB&gt;</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observable 被观察者</span></span><br><span class="line"><span class="keyword">type</span> Observable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Attach(observer ...ObserverInterface) Observable</span><br><span class="line">	Detach(observer ObserverInterface) Observable</span><br><span class="line">	Notify() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObservableConcrete 一个具体的 订单状态变化的被观察者</span></span><br><span class="line"><span class="keyword">type</span> ObservableConcrete <span class="keyword">struct</span> &#123;</span><br><span class="line">	observerList []ObserverInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach 注册观察者</span></span><br><span class="line"><span class="comment">// @param $observer ObserverInterface 观察者列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *ObservableConcrete)</span> <span class="title">Attach</span><span class="params">(observer ...ObserverInterface)</span> <span class="title">Observable</span></span> &#123;</span><br><span class="line">	o.observerList = <span class="built_in">append</span>(o.observerList, observer...)</span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detach 注销观察者</span></span><br><span class="line"><span class="comment">// @param $observer ObserverInterface 待注销的观察者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *ObservableConcrete)</span> <span class="title">Detach</span><span class="params">(observer ObserverInterface)</span> <span class="title">Observable</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(o.observerList) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> o</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, observerItem := <span class="keyword">range</span> o.observerList &#123;</span><br><span class="line">		<span class="keyword">if</span> observer == observerItem &#123;</span><br><span class="line">			fmt.Println(runFuncName(), <span class="string">"注销:"</span>, reflect.TypeOf(observer))</span><br><span class="line">			o.observerList = <span class="built_in">append</span>(o.observerList[:k], o.observerList[k+<span class="number">1</span>:]...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify 通知观察者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *ObservableConcrete)</span> <span class="title">Notify</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code ...</span></span><br><span class="line">	<span class="keyword">for</span> _, observer := <span class="keyword">range</span> o.observerList &#123;</span><br><span class="line">		<span class="keyword">if</span> err = observer.Do(o); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObserverInterface 定义一个观察者的接口</span></span><br><span class="line"><span class="keyword">type</span> ObserverInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 自身的业务</span></span><br><span class="line">	Do(o Observable) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderStatus 修改订单状态</span></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *OrderStatus)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"修改订单状态..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderStatusLog 记录订单状态变更日志</span></span><br><span class="line"><span class="keyword">type</span> OrderStatusLog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *OrderStatusLog)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"记录订单状态变更日志..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CouponRefund 退优惠券</span></span><br><span class="line"><span class="keyword">type</span> CouponRefund <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *CouponRefund)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"退优惠券..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PromotionRefund 还优惠活动资格</span></span><br><span class="line"><span class="keyword">type</span> PromotionRefund <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *PromotionRefund)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"还优惠活动资格..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StockRefund 还库存</span></span><br><span class="line"><span class="keyword">type</span> StockRefund <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *StockRefund)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"还库存..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GiftCardRefund 还礼品卡</span></span><br><span class="line"><span class="keyword">type</span> GiftCardRefund <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *GiftCardRefund)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"还礼品卡..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WalletRefund 退钱包余额</span></span><br><span class="line"><span class="keyword">type</span> WalletRefund <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *WalletRefund)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"退钱包余额..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeliverBillStatus 修改发货单状态</span></span><br><span class="line"><span class="keyword">type</span> DeliverBillStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *DeliverBillStatus)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"修改发货单状态..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeliverBillStatusLog 记录发货单状态变更日志</span></span><br><span class="line"><span class="keyword">type</span> DeliverBillStatusLog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *DeliverBillStatusLog)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"记录发货单状态变更日志..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Refund 生成退款单</span></span><br><span class="line"><span class="keyword">type</span> Refund <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *Refund)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"生成退款单..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoice 生成发票-红票</span></span><br><span class="line"><span class="keyword">type</span> Invoice <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *Invoice)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"生成发票-红票..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Email 发邮件</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *Email)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"发邮件..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sms 发短信</span></span><br><span class="line"><span class="keyword">type</span> Sms <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *Sms)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"发短信..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WechatNotify 发微信消息</span></span><br><span class="line"><span class="keyword">type</span> WechatNotify <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(observer *WechatNotify)</span> <span class="title">Do</span><span class="params">(o Observable)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// code...</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"发微信消息..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 未支付取消订单 “主题”</span></span><br><span class="line">	fmt.Println(<span class="string">"----------------------- 未支付取消订单 “主题”"</span>)</span><br><span class="line">	orderUnPaidCancelSubject := &amp;ObservableConcrete&#123;&#125;</span><br><span class="line">	orderUnPaidCancelSubject.Attach(</span><br><span class="line">		&amp;OrderStatus&#123;&#125;,</span><br><span class="line">		&amp;OrderStatusLog&#123;&#125;,</span><br><span class="line">		&amp;CouponRefund&#123;&#125;,</span><br><span class="line">		&amp;PromotionRefund&#123;&#125;,</span><br><span class="line">		&amp;StockRefund&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line">	orderUnPaidCancelSubject.Notify()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 超时关单 “主题”</span></span><br><span class="line">	fmt.Println(<span class="string">"----------------------- 超时关单 “主题”"</span>)</span><br><span class="line">	orderOverTimeSubject := &amp;ObservableConcrete&#123;&#125;</span><br><span class="line">	orderOverTimeSubject.Attach(</span><br><span class="line">		&amp;OrderStatus&#123;&#125;,</span><br><span class="line">		&amp;OrderStatusLog&#123;&#125;,</span><br><span class="line">		&amp;CouponRefund&#123;&#125;,</span><br><span class="line">		&amp;PromotionRefund&#123;&#125;,</span><br><span class="line">		&amp;StockRefund&#123;&#125;,</span><br><span class="line">		&amp;Email&#123;&#125;,</span><br><span class="line">		&amp;Sms&#123;&#125;,</span><br><span class="line">		&amp;WechatNotify&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line">	orderOverTimeSubject.Notify()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 已支付取消订单 “主题”</span></span><br><span class="line">	fmt.Println(<span class="string">"----------------------- 已支付取消订单 “主题”"</span>)</span><br><span class="line">	orderPaidCancelSubject := &amp;ObservableConcrete&#123;&#125;</span><br><span class="line">	orderPaidCancelSubject.Attach(</span><br><span class="line">		&amp;OrderStatus&#123;&#125;,</span><br><span class="line">		&amp;OrderStatusLog&#123;&#125;,</span><br><span class="line">		&amp;CouponRefund&#123;&#125;,</span><br><span class="line">		&amp;PromotionRefund&#123;&#125;,</span><br><span class="line">		&amp;StockRefund&#123;&#125;,</span><br><span class="line">		&amp;GiftCardRefund&#123;&#125;,</span><br><span class="line">		&amp;WalletRefund&#123;&#125;,</span><br><span class="line">		&amp;Refund&#123;&#125;,</span><br><span class="line">		&amp;Invoice&#123;&#125;,</span><br><span class="line">		&amp;Email&#123;&#125;,</span><br><span class="line">		&amp;Sms&#123;&#125;,</span><br><span class="line">		&amp;WechatNotify&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line">	orderPaidCancelSubject.Notify()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 取消发货单 “主题”</span></span><br><span class="line">	fmt.Println(<span class="string">"----------------------- 取消发货单 “主题”"</span>)</span><br><span class="line">	deliverBillCancelSubject := &amp;ObservableConcrete&#123;&#125;</span><br><span class="line">	deliverBillCancelSubject.Attach(</span><br><span class="line">		&amp;OrderStatus&#123;&#125;,</span><br><span class="line">		&amp;OrderStatusLog&#123;&#125;,</span><br><span class="line">		&amp;DeliverBillStatus&#123;&#125;,</span><br><span class="line">		&amp;DeliverBillStatusLog&#123;&#125;,</span><br><span class="line">		&amp;StockRefund&#123;&#125;,</span><br><span class="line">		&amp;GiftCardRefund&#123;&#125;,</span><br><span class="line">		&amp;WalletRefund&#123;&#125;,</span><br><span class="line">		&amp;Refund&#123;&#125;,</span><br><span class="line">		&amp;Invoice&#123;&#125;,</span><br><span class="line">		&amp;Email&#123;&#125;,</span><br><span class="line">		&amp;Sms&#123;&#125;,</span><br><span class="line">		&amp;WechatNotify&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line">	deliverBillCancelSubject.Notify()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 拒收 “主题”</span></span><br><span class="line">	fmt.Println(<span class="string">"----------------------- 拒收 “主题”"</span>)</span><br><span class="line">	deliverBillRejectSubject := &amp;ObservableConcrete&#123;&#125;</span><br><span class="line">	deliverBillRejectSubject.Attach(</span><br><span class="line">		&amp;OrderStatus&#123;&#125;,</span><br><span class="line">		&amp;OrderStatusLog&#123;&#125;,</span><br><span class="line">		&amp;DeliverBillStatus&#123;&#125;,</span><br><span class="line">		&amp;DeliverBillStatusLog&#123;&#125;,</span><br><span class="line">		&amp;StockRefund&#123;&#125;,</span><br><span class="line">		&amp;GiftCardRefund&#123;&#125;,</span><br><span class="line">		&amp;WalletRefund&#123;&#125;,</span><br><span class="line">		&amp;Refund&#123;&#125;,</span><br><span class="line">		&amp;Invoice&#123;&#125;,</span><br><span class="line">		&amp;Email&#123;&#125;,</span><br><span class="line">		&amp;Sms&#123;&#125;,</span><br><span class="line">		&amp;WechatNotify&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line">	deliverBillRejectSubject.Notify()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未来可以快速的根据业务的变化 创建新的主题 从而快速构建新的业务接口</span></span><br><span class="line">	fmt.Println(<span class="string">"----------------------- 未来的扩展..."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取正在运行的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFuncName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	pc := <span class="built_in">make</span>([]<span class="keyword">uintptr</span>, <span class="number">1</span>)</span><br><span class="line">	runtime.Callers(<span class="number">2</span>, pc)</span><br><span class="line">	f := runtime.FuncForPC(pc[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> f.Name()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Running] go run &quot;../easy-tips/go/src/patterns/observer/observer.go&quot;</span><br><span class="line">----------------------- 未支付取消订单 “主题”</span><br><span class="line">main.(*OrderStatus).Do 修改订单状态...</span><br><span class="line">main.(*OrderStatusLog).Do 记录订单状态变更日志...</span><br><span class="line">main.(*CouponRefund).Do 退优惠券...</span><br><span class="line">main.(*PromotionRefund).Do 还优惠活动资格...</span><br><span class="line">main.(*StockRefund).Do 还库存...</span><br><span class="line">----------------------- 超时关单 “主题”</span><br><span class="line">main.(*OrderStatus).Do 修改订单状态...</span><br><span class="line">main.(*OrderStatusLog).Do 记录订单状态变更日志...</span><br><span class="line">main.(*CouponRefund).Do 退优惠券...</span><br><span class="line">main.(*PromotionRefund).Do 还优惠活动资格...</span><br><span class="line">main.(*StockRefund).Do 还库存...</span><br><span class="line">main.(*Email).Do 发邮件...</span><br><span class="line">main.(*Sms).Do 发短信...</span><br><span class="line">main.(*WechatNotify).Do 发微信消息...</span><br><span class="line">----------------------- 已支付取消订单 “主题”</span><br><span class="line">main.(*OrderStatus).Do 修改订单状态...</span><br><span class="line">main.(*OrderStatusLog).Do 记录订单状态变更日志...</span><br><span class="line">main.(*CouponRefund).Do 退优惠券...</span><br><span class="line">main.(*PromotionRefund).Do 还优惠活动资格...</span><br><span class="line">main.(*StockRefund).Do 还库存...</span><br><span class="line">main.(*GiftCardRefund).Do 还礼品卡...</span><br><span class="line">main.(*WalletRefund).Do 退钱包余额...</span><br><span class="line">main.(*Refund).Do 生成退款单...</span><br><span class="line">main.(*Invoice).Do 生成发票-红票...</span><br><span class="line">main.(*Email).Do 发邮件...</span><br><span class="line">main.(*Sms).Do 发短信...</span><br><span class="line">main.(*WechatNotify).Do 发微信消息...</span><br><span class="line">----------------------- 取消发货单 “主题”</span><br><span class="line">main.(*OrderStatus).Do 修改订单状态...</span><br><span class="line">main.(*OrderStatusLog).Do 记录订单状态变更日志...</span><br><span class="line">main.(*DeliverBillStatus).Do 修改发货单状态...</span><br><span class="line">main.(*DeliverBillStatusLog).Do 记录发货单状态变更日志...</span><br><span class="line">main.(*StockRefund).Do 还库存...</span><br><span class="line">main.(*GiftCardRefund).Do 还礼品卡...</span><br><span class="line">main.(*WalletRefund).Do 退钱包余额...</span><br><span class="line">main.(*Refund).Do 生成退款单...</span><br><span class="line">main.(*Invoice).Do 生成发票-红票...</span><br><span class="line">main.(*Email).Do 发邮件...</span><br><span class="line">main.(*Sms).Do 发短信...</span><br><span class="line">main.(*WechatNotify).Do 发微信消息...</span><br><span class="line">----------------------- 拒收 “主题”</span><br><span class="line">main.(*OrderStatus).Do 修改订单状态...</span><br><span class="line">main.(*OrderStatusLog).Do 记录订单状态变更日志...</span><br><span class="line">main.(*DeliverBillStatus).Do 修改发货单状态...</span><br><span class="line">main.(*DeliverBillStatusLog).Do 记录发货单状态变更日志...</span><br><span class="line">main.(*StockRefund).Do 还库存...</span><br><span class="line">main.(*GiftCardRefund).Do 还礼品卡...</span><br><span class="line">main.(*WalletRefund).Do 退钱包余额...</span><br><span class="line">main.(*Refund).Do 生成退款单...</span><br><span class="line">main.(*Invoice).Do 生成发票-红票...</span><br><span class="line">main.(*Email).Do 发邮件...</span><br><span class="line">main.(*Sms).Do 发短信...</span><br><span class="line">main.(*WechatNotify).Do 发微信消息...</span><br></pre></td></tr></table></figure>
<h2 id="结语-1"><a href="#结语-1" class="headerlink" title="结语"></a>结语</h2><p>最后总结下，「观察者模式」抽象过程的核心是：</p>
<ul>
<li>被依赖的“主题”</li>
<li>被通知的“订阅者”</li>
<li>“订阅者”按需<strong>订阅</strong>“主题”</li>
<li>“主题”变化<strong>通知</strong>“订阅者”</li>
</ul>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="什么是「策略模式」？"><a href="#什么是「策略模式」？" class="headerlink" title="什么是「策略模式」？"></a>什么是「策略模式」？</h2><p>「策略模式」比较简单，大家平常工作中应该经常使用到，所以本文作为复习，帮助大家温故知新。我们先来看下定义：</p>
<blockquote>
<p>不同的算法按照统一的标准封装，客户端根据不同的场景，决策使用何种算法。</p>
</blockquote>
<p>上面的概念的关键词：</p>
<ul>
<li>算法：就是行为</li>
<li>标准：就是interface</li>
<li>客户端：客户端是相对的，谁调用谁就是客户端</li>
<li>场景：判断条件</li>
<li>决策：判断的过程</li>
</ul>
<p>概念很容易理解，不多说。</p>
<p>「策略模式」的优势：</p>
<ul>
<li>典型的高内聚：算法和算法之间完全独立、互不干扰</li>
<li>典型的松耦合：客户端依赖的是接口的抽象方法</li>
<li>沉淀：每一个封装好的算法都是这个技术团队的财富，且未来可以被轻易的修改、复用</li>
</ul>
<h2 id="什么真实业务场景可以用「策略模式」？"><a href="#什么真实业务场景可以用「策略模式」？" class="headerlink" title="什么真实业务场景可以用「策略模式」？"></a>什么真实业务场景可以用「策略模式」？</h2><blockquote>
<p>每一行代码下面的十字路口</p>
</blockquote>
<p>当代码的下一步面临选择的时候都可以使用「策略模式」，我们把不同选择的算法按照统一的标准封装，得到一类算法集的过程，就是实现「策略模式」的过程。</p>
<blockquote>
<p>我们有哪些真实业务场景可以用「策略模式」呢？</p>
</blockquote>
<p>比如：</p>
<ul>
<li>缓存: 使用什么样的nosql</li>
<li>存储: 使用什么样的DB</li>
<li>支付: 使用什么样的支付方式</li>
<li>等等… </li>
</ul>
<p>本文以<strong>支付接口</strong>举例，说明「策略模式」的具体使用。</p>
<h2 id="怎么用「策略模式」？"><a href="#怎么用「策略模式」？" class="headerlink" title="怎么用「策略模式」？"></a>怎么用「策略模式」？</h2><p>关于怎么用，完全可以生搬硬套我总结的使用设计模式的四个步骤：</p>
<ul>
<li>业务梳理</li>
<li>业务流程图</li>
<li>代码建模</li>
<li>代码demo</li>
</ul>
<h4 id="业务梳理-2"><a href="#业务梳理-2" class="headerlink" title="业务梳理"></a>业务梳理</h4><p>我们以某团的订单支付页面为例，页面上的每一个支付选项都是一个支付策略。如下：</p>
<p>用户可以使用：</p>
<ul>
<li>美团支付(策略)</li>
<li>微信支付(策略)</li>
<li>支付宝支付(策略)</li>
</ul>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200424131625.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200424131625.png" style="width:50%"></a><br></p>

<p>用户决定使用美团支付下的银行卡支付方式的参数</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200424132214.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200424132214.png" style="width:50%"></a><br></p>

<p>用户决定使用支付宝网页版支付方式的参数</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200424132232.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200424132232.png" style="width:50%"></a><br></p>

<blockquote>
<p>注：不一定完全准确。</p>
</blockquote>
<h4 id="业务流程图-1"><a href="#业务流程图-1" class="headerlink" title="业务流程图"></a>业务流程图</h4><p>我们通过梳理的文本业务流程得到了如下的业务流程图：</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200425192752.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200425192752.png" style="width:100%"></a><br></p>

<blockquote>
<p>注：流程不一定完全准确。</p>
</blockquote>
<h4 id="代码建模-2"><a href="#代码建模-2" class="headerlink" title="代码建模"></a>代码建模</h4><p>「策略模式」的核心是接口：</p>
<ul>
<li><code>PaymentInterface</code><ul>
<li><code>Pay(ctx *Context) error</code> 当前支付方式的支付逻辑</li>
<li><code>Refund(ctx *Context) error</code> 当前支付方式的退款逻辑</li>
</ul>
</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义一个支付接口</span><br><span class="line">- `PaymentInterface`</span><br><span class="line">    + 抽象方法`Pay(ctx *Context) error`: 当前支付方式的支付逻辑</span><br><span class="line">	+ 抽象方法`Refund(ctx *Context) error`: 当前支付方式的退款逻辑</span><br><span class="line"></span><br><span class="line">// 定义具体的支付方式 实现接口`PaymentInterface`</span><br><span class="line"></span><br><span class="line">- 具体的微信支付方式`WechatPay`</span><br><span class="line">    +  实现方法`Pay`: 支付逻辑</span><br><span class="line">	+  实现方法`Refund`: 支付逻辑</span><br><span class="line">- 具体的支付宝支付网页版方式`AliPayWap`</span><br><span class="line">    +  实现方法`Pay`: 支付逻辑</span><br><span class="line">	+  实现方法`Refund`: 支付逻辑</span><br><span class="line">- 具体的支付宝支付网页版方式`BankPay`</span><br><span class="line">    +  实现方法`Pay`: 支付逻辑</span><br><span class="line">	+  实现方法`Refund`: 支付逻辑</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">通过接口参数pay_type的值判断是哪种支付方式策略</span><br></pre></td></tr></table></figure>
<p>同时得到了我们的UML图：</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200425151733.jpg" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200425151733.jpg" style="width:100%"></a><br></p>

<h4 id="代码demo-2"><a href="#代码demo-2" class="headerlink" title="代码demo"></a>代码demo</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Go设计模式实战系列</span></span><br><span class="line"><span class="comment">//策略模式</span></span><br><span class="line"><span class="comment">//@auhtor TIGERB&lt;https://github.com/TIGERB&gt;</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// ConstWechatPay 微信支付</span></span><br><span class="line">	ConstWechatPay = <span class="string">"wechat_pay"</span></span><br><span class="line">	<span class="comment">// ConstAliPayWap 支付宝支付 网页版</span></span><br><span class="line">	ConstAliPayWap = <span class="string">"AliPayWapwap"</span></span><br><span class="line">	<span class="comment">// ConstBankPay 银行卡支付</span></span><br><span class="line">	ConstBankPay = <span class="string">"quickbank"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context 上下文</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 用户选择的支付方式</span></span><br><span class="line">	PayType <span class="keyword">string</span> <span class="string">`json:"pay_type"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PaymentInterface 支付方式接口</span></span><br><span class="line"><span class="keyword">type</span> PaymentInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Pay(ctx *Context) error    <span class="comment">// 支付</span></span><br><span class="line">	Refund(ctx *Context) error <span class="comment">// 退款</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WechatPay 微信支付</span></span><br><span class="line"><span class="keyword">type</span> WechatPay <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay 当前支付方式的支付逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WechatPay)</span> <span class="title">Pay</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前策略的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"使用微信支付..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Refund 当前支付方式的支付逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WechatPay)</span> <span class="title">Refund</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前策略的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"使用微信退款..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliPayWap 支付宝网页版</span></span><br><span class="line"><span class="keyword">type</span> AliPayWap <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay 当前支付方式的支付逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *AliPayWap)</span> <span class="title">Pay</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前策略的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"使用支付宝网页版支付..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Refund 当前支付方式的支付逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *AliPayWap)</span> <span class="title">Refund</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前策略的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"使用支付宝网页版退款..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BankPay 银行卡支付</span></span><br><span class="line"><span class="keyword">type</span> BankPay <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay 当前支付方式的支付逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *BankPay)</span> <span class="title">Pay</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前策略的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"使用银行卡支付..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Refund 当前支付方式的支付逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *BankPay)</span> <span class="title">Refund</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前策略的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"使用银行卡退款..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取正在运行的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFuncName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	pc := <span class="built_in">make</span>([]<span class="keyword">uintptr</span>, <span class="number">1</span>)</span><br><span class="line">	runtime.Callers(<span class="number">2</span>, pc)</span><br><span class="line">	f := runtime.FuncForPC(pc[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> f.Name()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 相对于被调用的支付策略 这里就是支付策略的客户端</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 业务上下文</span></span><br><span class="line">	ctx := &amp;Context&#123;</span><br><span class="line">		PayType: <span class="string">"wechat_pay"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取支付方式</span></span><br><span class="line">	<span class="keyword">var</span> instance PaymentInterface</span><br><span class="line">	<span class="keyword">switch</span> ctx.PayType &#123;</span><br><span class="line">	<span class="keyword">case</span> ConstWechatPay:</span><br><span class="line">		instance = &amp;WechatPay&#123;&#125;</span><br><span class="line">	<span class="keyword">case</span> ConstAliPayWap:</span><br><span class="line">		instance = &amp;AliPayWap&#123;&#125;</span><br><span class="line">	<span class="keyword">case</span> ConstBankPay:</span><br><span class="line">		instance = &amp;BankPay&#123;&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"无效的支付方式"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 支付</span></span><br><span class="line">	instance.Pay(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Running] go run &quot;../easy-tips/go/src/patterns/strategy/strategy.go&quot;</span><br><span class="line">main.(*WechatPay).Pay 使用微信支付...</span><br></pre></td></tr></table></figure>
<h2 id="结语-2"><a href="#结语-2" class="headerlink" title="结语"></a>结语</h2><p>最后总结下，「策略模式」抽象过程的核心是：</p>
<p>在<code>每一行代码下面的十字路口</code></p>
<ul>
<li>声明标准：定义<code>interface</code></li>
<li>封装算法：按照标准<code>interface</code>封装分支代码，得到每一个具体策略</li>
<li>构建算法集：每一个具体策略构成策略池子 -&gt; 这就是沉淀的过程</li>
</ul>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="什么是「状态模式」？"><a href="#什么是「状态模式」？" class="headerlink" title="什么是「状态模式」？"></a>什么是「状态模式」？</h2><blockquote>
<p>不同的算法按照统一的标准封装，根据不同的<strong>内部状态</strong>，决策使用何种算法</p>
</blockquote>
<h3 id="「状态模式」和「策略模式」的区别"><a href="#「状态模式」和「策略模式」的区别" class="headerlink" title="「状态模式」和「策略模式」的区别"></a>「状态模式」和「策略模式」的区别</h3><ul>
<li>策略模式：依靠客户决策</li>
<li>状态模式：依靠内部状态决策</li>
</ul>
<h2 id="什么真实业务场景可以用「状态模式」？"><a href="#什么真实业务场景可以用「状态模式」？" class="headerlink" title="什么真实业务场景可以用「状态模式」？"></a>什么真实业务场景可以用「状态模式」？</h2><blockquote>
<p>具体算法的选取是由内部状态决定的</p>
</blockquote>
<ul>
<li>首先，内部存在多种状态</li>
<li>其次，不同的状态的业务逻辑各不相同</li>
</ul>
<blockquote>
<p>我们有哪些真实业务场景可以用「状态模式」呢？</p>
</blockquote>
<p>比如，发送短信接口、限流等等。</p>
<ul>
<li>短信接口<ul>
<li>服务内部根据最优算法，实时推举出最优的短信服务商，并修改<strong>使用何种短信服务商的状态</strong></li>
</ul>
</li>
<li>限流<ul>
<li>服务内部根据当前的实时流量，选择不同的限流算法，并修改<strong>使用何种限流算法的状态</strong></li>
</ul>
</li>
</ul>
<h2 id="怎么用「状态模式」？"><a href="#怎么用「状态模式」？" class="headerlink" title="怎么用「状态模式」？"></a>怎么用「状态模式」？</h2><p>关于怎么用，完全可以生搬硬套我总结的使用设计模式的四个步骤：</p>
<ul>
<li>业务梳理</li>
<li>业务流程图</li>
<li>代码建模</li>
<li>代码demo</li>
</ul>
<h4 id="业务梳理-3"><a href="#业务梳理-3" class="headerlink" title="业务梳理"></a>业务梳理</h4><p>先来看看一个短信验证码登录的界面。</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200522131127.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200522131127.png" style="width:100%"></a><br></p>

<p>可以得到：</p>
<ul>
<li>发送短信，用户只需要输入手机号即可</li>
<li>至于短信服务使用何种短信服务商，是由短信服务自身的<strong>当前短信服务商实例的状态</strong>决定</li>
<li><strong>当前短信服务商实例的状态</strong>又是由服务自身的算法修改</li>
</ul>
<h4 id="业务流程图-2"><a href="#业务流程图-2" class="headerlink" title="业务流程图"></a>业务流程图</h4><p>我们通过梳理的文本业务流程得到了如下的业务流程图：</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200522130715.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200522130715.png" style="width:100%"></a><br></p>

<h4 id="代码建模-3"><a href="#代码建模-3" class="headerlink" title="代码建模"></a>代码建模</h4><p>「状态模式」的核心是：</p>
<ul>
<li>一个接口:<ul>
<li>短信服务接口<code>SmsServiceInterface</code></li>
</ul>
</li>
<li>一个实体类:<ul>
<li>状态管理实体类<code>StateManager</code></li>
</ul>
</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义一个短信服务接口</span><br><span class="line">- 接口`SmsServiceInterface`</span><br><span class="line">	+ 抽象方法`Send(ctx *Context) error`发送短信的抽象方法</span><br><span class="line"></span><br><span class="line">// 定义具体的短信服务实体类 实现接口`SmsServiceInterface`</span><br><span class="line"></span><br><span class="line">- 实体类`ServiceProviderAliyun`</span><br><span class="line">	+ 成员方法`Send(ctx *Context) error`具体的发送短信逻辑</span><br><span class="line">- 实体类`ServiceProviderTencent`</span><br><span class="line">	+ 成员方法`Send(ctx *Context) error`具体的发送短信逻辑</span><br><span class="line">- 实体类`ServiceProviderYunpian`</span><br><span class="line">	+ 成员方法`Send(ctx *Context) error`具体的发送短信逻辑</span><br><span class="line"></span><br><span class="line">// 定义状态管理实体类`StateManager`</span><br><span class="line">- 成员属性</span><br><span class="line">	+ `currentProviderType ProviderType`当前使用的服务提供商类型</span><br><span class="line">	+ `currentProvider SmsServiceInterface`当前使用的服务提供商实例</span><br><span class="line">	+ `setStateDuration time.Duration`更新状态时间间隔</span><br><span class="line">- 成员方法</span><br><span class="line">	+ `initState(duration time.Duration)`初始化状态</span><br><span class="line">	+ `setState(t time.Time)`设置状态</span><br></pre></td></tr></table></figure>
<p>同时得到了我们的UML图：</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200527141350.jpg" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200527141350.jpg" style="width:100%"></a><br></p>

<h4 id="代码demo-3"><a href="#代码demo-3" class="headerlink" title="代码demo"></a>代码demo</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Go设计模式实战系列</span></span><br><span class="line"><span class="comment">//状态模式</span></span><br><span class="line"><span class="comment">//@auhtor TIGERB&lt;https://github.com/TIGERB&gt;</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context 上下文</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	Tel        <span class="keyword">string</span> <span class="comment">// 手机号</span></span><br><span class="line">	Text       <span class="keyword">string</span> <span class="comment">// 短信内容</span></span><br><span class="line">	TemplateID <span class="keyword">string</span> <span class="comment">// 短信模板ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SmsServiceInterface 短信服务接口</span></span><br><span class="line"><span class="keyword">type</span> SmsServiceInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(ctx *Context) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceProviderAliyun 阿里云</span></span><br><span class="line"><span class="keyword">type</span> ServiceProviderAliyun <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send Send</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceProviderAliyun)</span> <span class="title">Send</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"【阿里云】短信发送成功，手机号:"</span>+ctx.Tel)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceProviderTencent 腾讯云</span></span><br><span class="line"><span class="keyword">type</span> ServiceProviderTencent <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send Send</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceProviderTencent)</span> <span class="title">Send</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"【腾讯云】短信发送成功，手机号:"</span>+ctx.Tel)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceProviderYunpian 云片</span></span><br><span class="line"><span class="keyword">type</span> ServiceProviderYunpian <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send Send</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceProviderYunpian)</span> <span class="title">Send</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"【云片】短信发送成功，手机号:"</span>+ctx.Tel)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取正在运行的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFuncName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	pc := <span class="built_in">make</span>([]<span class="keyword">uintptr</span>, <span class="number">1</span>)</span><br><span class="line">	runtime.Callers(<span class="number">2</span>, pc)</span><br><span class="line">	f := runtime.FuncForPC(pc[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> f.Name()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProviderType 短信服务提供商类型</span></span><br><span class="line"><span class="keyword">type</span> ProviderType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// ProviderTypeAliyun 阿里云</span></span><br><span class="line">	ProviderTypeAliyun ProviderType = <span class="string">"aliyun"</span></span><br><span class="line">	<span class="comment">// ProviderTypeTencent 腾讯云</span></span><br><span class="line">	ProviderTypeTencent ProviderType = <span class="string">"tencent"</span></span><br><span class="line">	<span class="comment">// ProviderTypeYunpian 云片</span></span><br><span class="line">	ProviderTypeYunpian ProviderType = <span class="string">"yunpian"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// stateManagerInstance 当前使用的服务提供商实例</span></span><br><span class="line">	<span class="comment">// 默认aliyun</span></span><br><span class="line">	stateManagerInstance *StateManager</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// StateManager 状态管理</span></span><br><span class="line"><span class="keyword">type</span> StateManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// CurrentProviderType 当前使用的服务提供商类型</span></span><br><span class="line">	<span class="comment">// 默认aliyun</span></span><br><span class="line">	currentProviderType ProviderType</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CurrentProvider 当前使用的服务提供商实例</span></span><br><span class="line">	<span class="comment">// 默认aliyun</span></span><br><span class="line">	currentProvider SmsServiceInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新状态时间间隔</span></span><br><span class="line">	setStateDuration time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initState 初始化状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *StateManager)</span> <span class="title">initState</span><span class="params">(duration time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	m.setStateDuration = duration</span><br><span class="line">	m.setState(time.Now())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定时器更新状态</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 每一段时间后根据回调的发送成功率 计算得到当前应该使用的 厂商</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> t := &lt;-time.NewTicker(m.setStateDuration).C:</span><br><span class="line">				m.setState(t)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setState 设置状态</span></span><br><span class="line"><span class="comment">// 根据短信云商回调的短信发送成功率 得到下阶段发送短信使用哪个厂商的服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *StateManager)</span> <span class="title">setState</span><span class="params">(t time.Time)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里用随机模拟</span></span><br><span class="line">	ProviderTypeArray := [<span class="number">3</span>]ProviderType&#123;</span><br><span class="line">		ProviderTypeAliyun,</span><br><span class="line">		ProviderTypeTencent,</span><br><span class="line">		ProviderTypeYunpian,</span><br><span class="line">	&#125;</span><br><span class="line">	m.currentProviderType = ProviderTypeArray[rand.Intn(<span class="built_in">len</span>(ProviderTypeArray))]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> m.currentProviderType &#123;</span><br><span class="line">	<span class="keyword">case</span> ProviderTypeAliyun:</span><br><span class="line">		m.currentProvider = &amp;ServiceProviderAliyun&#123;&#125;</span><br><span class="line">	<span class="keyword">case</span> ProviderTypeTencent:</span><br><span class="line">		m.currentProvider = &amp;ServiceProviderTencent&#123;&#125;</span><br><span class="line">	<span class="keyword">case</span> ProviderTypeYunpian:</span><br><span class="line">		m.currentProvider = &amp;ServiceProviderYunpian&#123;&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"无效的短信服务商"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"时间：%s| 变更短信发送厂商为: %s \n"</span>, t.Format(<span class="string">"2006-01-02 15:04:05"</span>), m.currentProviderType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getState 获取当前状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *StateManager)</span> <span class="title">getState</span><span class="params">()</span> <span class="title">SmsServiceInterface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.currentProvider</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetState 获取当前状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetState</span><span class="params">()</span> <span class="title">SmsServiceInterface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> stateManagerInstance.getState()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化状态管理</span></span><br><span class="line">	stateManagerInstance = &amp;StateManager&#123;&#125;</span><br><span class="line">	stateManagerInstance.initState(<span class="number">300</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟发送短信的接口</span></span><br><span class="line">	sendSms := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 发送短信</span></span><br><span class="line">		GetState().Send(&amp;Context&#123;</span><br><span class="line">			Tel:        <span class="string">"+8613666666666"</span>,</span><br><span class="line">			Text:       <span class="string">"3232"</span>,</span><br><span class="line">			TemplateID: <span class="string">"TYSHK_01"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟用户调用发送短信的接口</span></span><br><span class="line">	sendSms()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	sendSms()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	sendSms()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	sendSms()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	sendSms()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Running] go run &quot;./easy-tips/go/src/patterns/state/state.go&quot;</span><br><span class="line">时间：2020-05-30 18:02:37| 变更短信发送厂商为: yunpian </span><br><span class="line">main.(*ServiceProviderYunpian).Send 【云片】短信发送成功，手机号:+8613666666666</span><br><span class="line">时间：2020-05-30 18:02:37| 变更短信发送厂商为: aliyun </span><br><span class="line">时间：2020-05-30 18:02:38| 变更短信发送厂商为: yunpian </span><br><span class="line">时间：2020-05-30 18:02:38| 变更短信发送厂商为: yunpian </span><br><span class="line">main.(*ServiceProviderYunpian).Send 【云片】短信发送成功，手机号:+8613666666666</span><br><span class="line">时间：2020-05-30 18:02:38| 变更短信发送厂商为: tencent </span><br><span class="line">时间：2020-05-30 18:02:39| 变更短信发送厂商为: aliyun </span><br><span class="line">时间：2020-05-30 18:02:39| 变更短信发送厂商为: tencent </span><br><span class="line">main.(*ServiceProviderTencent).Send 【腾讯云】短信发送成功，手机号:+8613666666666</span><br><span class="line">时间：2020-05-30 18:02:39| 变更短信发送厂商为: yunpian </span><br><span class="line">时间：2020-05-30 18:02:40| 变更短信发送厂商为: tencent </span><br><span class="line">时间：2020-05-30 18:02:40| 变更短信发送厂商为: aliyun </span><br><span class="line">main.(*ServiceProviderAliyun).Send 【阿里云】短信发送成功，手机号:+8613666666666</span><br><span class="line">时间：2020-05-30 18:02:40| 变更短信发送厂商为: yunpian </span><br><span class="line">时间：2020-05-30 18:02:40| 变更短信发送厂商为: tencent </span><br><span class="line">时间：2020-05-30 18:02:41| 变更短信发送厂商为: aliyun </span><br><span class="line">时间：2020-05-30 18:02:41| 变更短信发送厂商为: yunpian </span><br><span class="line">main.(*ServiceProviderYunpian).Send 【云片】短信发送成功，手机号:+8613666666666</span><br></pre></td></tr></table></figure>
<h2 id="结语-3"><a href="#结语-3" class="headerlink" title="结语"></a>结语</h2><p>最后总结下，「状态模式」抽象过程的核心是：</p>
<ul>
<li>每一个状态映射对应行为</li>
<li>行为实现同一个接口<code>interface</code></li>
<li>行为是内部的一个状态</li>
<li>状态是不断变化的</li>
</ul>
<h1 id="并发组合模式"><a href="#并发组合模式" class="headerlink" title="并发组合模式"></a>并发组合模式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍「组合模式」结合Go语言天生的并发特性，如何在真实业务场景中使用。</p>
<p>之前文章<a href="#组合模式">《代码组件 | Go设计模式实战》</a>已经介绍了「组合模式」的概念，以及在业务中的使用。今天我们结合Go语言天生的并发特性，升级「组合模式」为「并发组合模式」。</p>
<p>我们先来简单回顾下「组合模式」的知识，详细可以查看上篇文章<a href="#组合模式">《代码组件 | Go设计模式实战》</a></p>
<h2 id="什么是「并发组合模式」？"><a href="#什么是「并发组合模式」？" class="headerlink" title="什么是「并发组合模式」？"></a>什么是「并发组合模式」？</h2><p>组合模式的概念：</p>
<blockquote>
<p>一个具有层级关系的对象由一系列拥有父子关系的对象通过树形结构组成。</p>
</blockquote>
<p>并发组合模式的概念：</p>
<blockquote>
<p>一个具有层级关系的对象由一系列拥有父子关系的对象通过树形结构组成，子对象即可被串行执行，也可被并发执行</p>
</blockquote>
<p>并发组合模式的优势：</p>
<ul>
<li>原本串行的业务(存在阻塞的部分，比如网络IO等)可以被并发执行，利用多核优势提升性能。</li>
</ul>
<h2 id="什么真实业务场景可以用「并发组合模式」？"><a href="#什么真实业务场景可以用「并发组合模式」？" class="headerlink" title="什么真实业务场景可以用「并发组合模式」？"></a>什么真实业务场景可以用「并发组合模式」？</h2><p>我们还是以「组合模式」中的“订单结算页面”为例，继续来看看某东的订单结算页面：</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20200331124724.jpeg" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20200331124724.jpeg" style="width:30%"></a><br></p>

<p>从页面的展示形式上，可以看出：</p>
<ul>
<li>页面由多个模块构成，比如：<ul>
<li>地址模块：获取用户地址数据</li>
<li>支付方式模块：获取支付方式列表</li>
<li>店铺模块：获取店铺、购物车选中商品等信息</li>
<li>发票模块：获取发票类型列表</li>
<li>优惠券模块：获取用户优惠券列表</li>
<li>某豆模块：获取用户积分信息</li>
<li>礼品卡模块：获取礼品卡列表列表</li>
<li>订单详细金额模块：获取订单金额信息</li>
</ul>
</li>
<li>单个模块可以由多个子模块构成<ul>
<li>店铺模块，又由如下模块构成：<ul>
<li>商品模块：获取购物车选中商品信息</li>
<li>售后模块：获取商品售后信息</li>
<li>优惠模块：获取商品参与的优惠活动信息</li>
<li>物流模块：获取商品支持的配送方式列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>按照「组合模式」的业务逻辑执行流程：</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20201103203539.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20201103203539.png" style="width:38%"></a><br></p>

<p>但是，我们很清楚有些模块之间并没有依赖，<strong>且该模块涉及服务远程调用等阻塞操作</strong>，比如：</p>
<ul>
<li>地址模块调用地址服务获取用户地址数据时。</li>
<li>支付方式模块也可以同时去读redis获取支付方式列表数据等等。</li>
</ul>
<p>所以:<strong>有的模块其实可以被并发的执行</strong>。</p>
<p>如果把上面不存在依赖关系的模块修改为并发的执行，则我们得到如下的执行流程：</p>
<p align="center"><br>  <a href="http://cdn.tigerb.cn/20201103203735.png" class="gallery-item" target="_blank" rel="noopener"><img src="http://cdn.tigerb.cn/20201103203735.png" style="width:100%"></a><br></p>

<h2 id="怎么用「并发组合模式」？"><a href="#怎么用「并发组合模式」？" class="headerlink" title="怎么用「并发组合模式」？"></a>怎么用「并发组合模式」？</h2><p>关于「并发组合模式」的建模过程完全可以参考之前文章<a href="#组合模式">《代码组件 | Go设计模式实战》</a>，我们这里只说说需要着重注意的地方。</p>
<p>「并发组合模式」的核心还是<code>Component</code>组件接口，我们先看看「组合模式」的<code>Component</code>组件接口如下(再之前的文章上做了优化，进一步封装提取了<code>BusinessLogicDo</code>方法)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Component 组件接口</span></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 添加一个子组件</span></span><br><span class="line">	Mount(c Component, components ...Component) error</span><br><span class="line">	<span class="comment">// 移除一个子组件</span></span><br><span class="line">	Remove(c Component) error</span><br><span class="line">	<span class="comment">// 执行当前组件业务和执行子组件</span></span><br><span class="line">	<span class="comment">// ctx 业务上下文</span></span><br><span class="line">	<span class="comment">// currentConponent 当前组件</span></span><br><span class="line">	Do(ctx *Context, currentConponent Component) error</span><br><span class="line">	<span class="comment">// 执行当前组件业务业务逻辑</span></span><br><span class="line">	BusinessLogicDo(ctx *Context) error</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	ChildsDo(ctx *Context) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看「并发组合模式」的Component`组件接口，如下(重点看和「组合模式」的区别)：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Component 组件接口</span></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 添加一个子组件</span></span><br><span class="line">	Mount(c Component, components ...Component) error</span><br><span class="line">	<span class="comment">// 移除一个子组件</span></span><br><span class="line">	Remove(c Component) error</span><br><span class="line">	<span class="comment">// 执行当前组件业务:`BusinessLogicDo`和执行子组件:`ChildsDo`</span></span><br><span class="line">	<span class="comment">// ctx 业务上下文</span></span><br><span class="line">	<span class="comment">// currentConponent 当前组件</span></span><br><span class="line">	<span class="comment">// wg 父组件的WaitGroup对象</span></span><br><span class="line">	<span class="comment">// 区别1：增加了WaitGroup对象参数，目的是等待并发子组件的执行完成。</span></span><br><span class="line">	Do(ctx *Context, currentConponent Component, wg *sync.WaitGroup) error</span><br><span class="line">	<span class="comment">// 执行当前组件业务逻辑</span></span><br><span class="line">	<span class="comment">// resChan 回写当前组件业务执行结果的channel</span></span><br><span class="line">	<span class="comment">// 区别2：增加了一个channel参数，目的是并发组件执行逻辑时引入了超时机制，需要一个channel接受组件的执行结果</span></span><br><span class="line">	BusinessLogicDo(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	ChildsDo(ctx *Context) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们详细再来看，相对于「组合模式」，引入并发之后需要着重关注如下几点：</p>
<ul>
<li>并发子组件需要设置超时时间：防止子组件执行时间过长，解决方案关键字<code>context.WithTimeout</code></li>
<li>区分普通组件和并发组件：合成复用基础组件，封装为并发基础组件</li>
<li>拥有并发子组件的父组件需要等待并发子组件执行完毕(包含超时)，解决方案关键字<code>sync.WaitGroup</code></li>
<li>并发子组件执行自身业务逻辑是需检测超时：防止子组件内部执行业务逻辑时间过长，解决方案关键字<code>select</code>和<code>&lt;-ctx.Done()</code></li>
</ul>
<h3 id="第一点：并发子组件需要设置超时时间"><a href="#第一点：并发子组件需要设置超时时间" class="headerlink" title="第一点：并发子组件需要设置超时时间"></a>第一点：并发子组件需要设置超时时间</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context 业务上下文</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// context.WithTimeout派生的子上下文</span></span><br><span class="line">	TimeoutCtx context.Context</span><br><span class="line">	<span class="comment">// 超时函数</span></span><br><span class="line">	context.CancelFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二点：区分普通组件和并发组件"><a href="#第二点：区分普通组件和并发组件" class="headerlink" title="第二点：区分普通组件和并发组件"></a>第二点：区分普通组件和并发组件</h3><p>增加新的并发基础组件结构体<code>BaseConcurrencyComponent</code>，并合成复用「组合模式」中的基础组件<code>BaseComponent</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BaseConcurrencyComponent 并发基础组件</span></span><br><span class="line"><span class="keyword">type</span> BaseConcurrencyComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">	<span class="comment">// 当前组件是否有并发子组件</span></span><br><span class="line">	HasChildConcurrencyComponents <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 并发子组件列表</span></span><br><span class="line">	ChildConcurrencyComponents []Component</span><br><span class="line">	<span class="comment">// wg 对象</span></span><br><span class="line">	*sync.WaitGroup</span><br><span class="line">	<span class="comment">// 当前组件业务执行结果channel</span></span><br><span class="line">	logicResChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 当前组件执行过程中的错误信息</span></span><br><span class="line">	Err error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三点：拥有并发子组件的父组件需要等待并发子组件执行完毕-包含超时"><a href="#第三点：拥有并发子组件的父组件需要等待并发子组件执行完毕-包含超时" class="headerlink" title="第三点：拥有并发子组件的父组件需要等待并发子组件执行完毕(包含超时)"></a>第三点：拥有并发子组件的父组件需要等待并发子组件执行完毕(包含超时)</h3><p>修改「组合模式」中的<code>ChildsDo</code>方法，使其支持并发执行子组件，主要修改和实现如下：</p>
<ul>
<li>通过<code>go</code>关键字执行子组件</li>
<li>通过<code>*WaitGroup.Wait()</code>等待子组件执行结果</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ChildsDo 执行子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseConcurrencyComponent)</span> <span class="title">ChildsDo</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> bc.WaitGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">		bc.WaitGroup = &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行并发子组件</span></span><br><span class="line">	<span class="keyword">for</span> _, childComponent := <span class="keyword">range</span> bc.ChildConcurrencyComponents &#123;</span><br><span class="line">		bc.WaitGroup.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> childComponent.Do(ctx, childComponent, bc.WaitGroup)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	<span class="keyword">for</span> _, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> err = childComponent.Do(ctx, childComponent, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> bc.HasChildConcurrencyComponents &#123;</span><br><span class="line">		<span class="comment">// 等待并发组件执行结果</span></span><br><span class="line">		bc.WaitGroup.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第四点：并发子组件执行自身业务逻辑是需检测超时"><a href="#第四点：并发子组件执行自身业务逻辑是需检测超时" class="headerlink" title="第四点：并发子组件执行自身业务逻辑是需检测超时"></a>第四点：并发子组件执行自身业务逻辑是需检测超时</h3><p><code>select</code>关键字context.WithTimeout()派生的子上下文Done()方案返回的channel，发生超时该channel会被关闭。具体实现代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Do 执行子组件</span></span><br><span class="line"><span class="comment">// ctx 业务上下文</span></span><br><span class="line"><span class="comment">// currentConponent 当前组件</span></span><br><span class="line"><span class="comment">// wg 父组件的waitgroup对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseConcurrencyComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context, currentConponent Component, wg *sync.WaitGroup)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="comment">// 初始化并发子组件channel</span></span><br><span class="line">	<span class="keyword">if</span> bc.logicResChan == <span class="literal">nil</span> &#123;</span><br><span class="line">		bc.logicResChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> currentConponent.BusinessLogicDo(bc.logicResChan)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 等待业务执行结果</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-bc.logicResChan:</span><br><span class="line">		<span class="comment">// 业务执行结果</span></span><br><span class="line">		fmt.Println(runFuncName(), <span class="string">"bc.BusinessLogicDo wait.done..."</span>)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="comment">// 超时等待</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.TimeoutCtx.Done():</span><br><span class="line">		<span class="comment">// 超时退出</span></span><br><span class="line">		fmt.Println(runFuncName(), <span class="string">"bc.BusinessLogicDo timeout..."</span>)</span><br><span class="line">		bc.Err = ErrConcurrencyComponentTimeout</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	err = currentConponent.ChildsDo(ctx)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码demo-4"><a href="#代码demo-4" class="headerlink" title="代码demo"></a>代码demo</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Go设计模式实战系列</span></span><br><span class="line"><span class="comment">//组合模式</span></span><br><span class="line"><span class="comment">//@auhtor TIGERB&lt;https://github.com/TIGERB&gt;</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//example:</span></span><br><span class="line"><span class="comment">// 创建一个根组件</span></span><br><span class="line"><span class="comment">// 如果子组件存在并发组件则父组件必须为并发组件</span></span><br><span class="line"><span class="comment">// type RootComponent struct &#123;</span></span><br><span class="line"><span class="comment">// 	BaseConcurrencyComponent</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func (bc *RootComponent) BusinessLogicDo(resChan chan interface&#123;&#125;) (err error) &#123;</span></span><br><span class="line"><span class="comment">// 	// do nothing</span></span><br><span class="line"><span class="comment">// 	return</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 创建一个并发组件</span></span><br><span class="line"><span class="comment">// type DemoConcurrenyComponent struct &#123;</span></span><br><span class="line"><span class="comment">// 	BaseConcurrencyComponent</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func (bc *DemoConcurrenyComponent) BusinessLogicDo(resChan chan interface&#123;&#125;) (err error) &#123;</span></span><br><span class="line"><span class="comment">// 	// 并发组件业务逻辑填充到这</span></span><br><span class="line"><span class="comment">// 	return</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 创建一个普通组件</span></span><br><span class="line"><span class="comment">// type DemoComponent struct &#123;</span></span><br><span class="line"><span class="comment">// 	BaseComponent</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func (bc *DemoComponent) BusinessLogicDo(resChan chan interface&#123;&#125;) (err error) &#123;</span></span><br><span class="line"><span class="comment">// 	// 普通组件业务逻辑填充到这</span></span><br><span class="line"><span class="comment">// 	return</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// // 普通组件</span></span><br><span class="line"><span class="comment">// root.Mount(</span></span><br><span class="line"><span class="comment">// 	&amp;DemoComponent&#123;&#125;,</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// // 并发组件</span></span><br><span class="line"><span class="comment">// root := &amp;RootComponent&#123;&#125;</span></span><br><span class="line"><span class="comment">// root.MountConcurrency(</span></span><br><span class="line"><span class="comment">// 	&amp;DemoConcurrenyComponent&#123;&#125;,</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// // 初始化业务上下文 并设置超时时间</span></span><br><span class="line"><span class="comment">// ctx := GetContext(5 * time.Second)</span></span><br><span class="line"><span class="comment">// defer ctx.CancelFunc()</span></span><br><span class="line"><span class="comment">// // 开始执行子组件</span></span><br><span class="line"><span class="comment">// root.ChildsDo(ctx)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// ErrConcurrencyComponentTimeout 并发组件业务超时</span></span><br><span class="line">	ErrConcurrencyComponentTimeout = errors.New(<span class="string">"Concurrency Component Timeout"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context 业务上下文</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// context.WithTimeout派生的子上下文</span></span><br><span class="line">	TimeoutCtx context.Context</span><br><span class="line">	<span class="comment">// 超时函数</span></span><br><span class="line">	context.CancelFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetContext 获取业务上下文实例</span></span><br><span class="line"><span class="comment">// d 超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetContext</span><span class="params">(d time.Duration)</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line">	c := &amp;Context&#123;&#125;</span><br><span class="line">	c.TimeoutCtx, c.CancelFunc = context.WithTimeout(context.Background(), d)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Component 组件接口</span></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 添加一个子组件</span></span><br><span class="line">	Mount(c Component, components ...Component) error</span><br><span class="line">	<span class="comment">// 移除一个子组件</span></span><br><span class="line">	Remove(c Component) error</span><br><span class="line">	<span class="comment">// 执行当前组件业务:`BusinessLogicDo`和执行子组件:`ChildsDo`</span></span><br><span class="line">	<span class="comment">// ctx 业务上下文</span></span><br><span class="line">	<span class="comment">// currentConponent 当前组件</span></span><br><span class="line">	<span class="comment">// wg 父组件的waitgroup对象</span></span><br><span class="line">	Do(ctx *Context, currentConponent Component, wg *sync.WaitGroup) error</span><br><span class="line">	<span class="comment">// 执行当前组件业务逻辑</span></span><br><span class="line">	<span class="comment">// resChan 回写当前组件业务执行结果的channel</span></span><br><span class="line">	BusinessLogicDo(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	ChildsDo(ctx *Context) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BaseComponent 基础组件</span></span><br><span class="line"><span class="comment">// 实现Add:添加一个子组件</span></span><br><span class="line"><span class="comment">// 实现Remove:移除一个子组件</span></span><br><span class="line"><span class="keyword">type</span> BaseComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 子组件列表</span></span><br><span class="line">	ChildComponents []Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mount 挂载一个子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">Mount</span><span class="params">(c Component, components ...Component)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents, c)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(components) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents, components...)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 移除一个子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">Remove</span><span class="params">(c Component)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(bc.ChildComponents) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> c == childComponent &#123;</span><br><span class="line">			fmt.Println(runFuncName(), <span class="string">"移除:"</span>, reflect.TypeOf(childComponent))</span><br><span class="line">			bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents[:k], bc.ChildComponents[k+<span class="number">1</span>:]...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行子组件</span></span><br><span class="line"><span class="comment">// ctx 业务上下文</span></span><br><span class="line"><span class="comment">// currentConponent 当前组件</span></span><br><span class="line"><span class="comment">// wg 父组件的waitgroup对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context, currentConponent Component, wg *sync.WaitGroup)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//执行当前组件业务代码</span></span><br><span class="line">	err = currentConponent.BusinessLogicDo(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	<span class="keyword">return</span> currentConponent.ChildsDo(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 当前组件业务逻辑代码填充处</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// do nothing</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChildsDo 执行子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">ChildsDo</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	<span class="keyword">for</span> _, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> err = childComponent.Do(ctx, childComponent, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BaseConcurrencyComponent 并发基础组件</span></span><br><span class="line"><span class="keyword">type</span> BaseConcurrencyComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">	<span class="comment">// 当前组件是否有并发子组件</span></span><br><span class="line">	HasChildConcurrencyComponents <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 并发子组件列表</span></span><br><span class="line">	ChildConcurrencyComponents []Component</span><br><span class="line">	<span class="comment">// wg 对象</span></span><br><span class="line">	*sync.WaitGroup</span><br><span class="line">	<span class="comment">// 当前组件业务执行结果channel</span></span><br><span class="line">	logicResChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 当前组件执行过程中的错误信息</span></span><br><span class="line">	Err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 移除一个子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseConcurrencyComponent)</span> <span class="title">Remove</span><span class="params">(c Component)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(bc.ChildComponents) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> c == childComponent &#123;</span><br><span class="line">			fmt.Println(runFuncName(), <span class="string">"移除:"</span>, reflect.TypeOf(childComponent))</span><br><span class="line">			bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents[:k], bc.ChildComponents[k+<span class="number">1</span>:]...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, childComponent := <span class="keyword">range</span> bc.ChildConcurrencyComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> c == childComponent &#123;</span><br><span class="line">			fmt.Println(runFuncName(), <span class="string">"移除:"</span>, reflect.TypeOf(childComponent))</span><br><span class="line">			bc.ChildConcurrencyComponents = <span class="built_in">append</span>(bc.ChildComponents[:k], bc.ChildComponents[k+<span class="number">1</span>:]...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MountConcurrency 挂载一个并发子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseConcurrencyComponent)</span> <span class="title">MountConcurrency</span><span class="params">(c Component, components ...Component)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	bc.HasChildConcurrencyComponents = <span class="literal">true</span></span><br><span class="line">	bc.ChildConcurrencyComponents = <span class="built_in">append</span>(bc.ChildConcurrencyComponents, c)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(components) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	bc.ChildConcurrencyComponents = <span class="built_in">append</span>(bc.ChildConcurrencyComponents, components...)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChildsDo 执行子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseConcurrencyComponent)</span> <span class="title">ChildsDo</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> bc.WaitGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">		bc.WaitGroup = &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行并发子组件</span></span><br><span class="line">	<span class="keyword">for</span> _, childComponent := <span class="keyword">range</span> bc.ChildConcurrencyComponents &#123;</span><br><span class="line">		bc.WaitGroup.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> childComponent.Do(ctx, childComponent, bc.WaitGroup)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	<span class="keyword">for</span> _, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> err = childComponent.Do(ctx, childComponent, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> bc.HasChildConcurrencyComponents &#123;</span><br><span class="line">		<span class="comment">// 等待并发组件执行结果</span></span><br><span class="line">		bc.WaitGroup.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行子组件</span></span><br><span class="line"><span class="comment">// ctx 业务上下文</span></span><br><span class="line"><span class="comment">// currentConponent 当前组件</span></span><br><span class="line"><span class="comment">// wg 父组件的waitgroup对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseConcurrencyComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context, currentConponent Component, wg *sync.WaitGroup)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="comment">// 初始化并发子组件channel</span></span><br><span class="line">	<span class="keyword">if</span> bc.logicResChan == <span class="literal">nil</span> &#123;</span><br><span class="line">		bc.logicResChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> currentConponent.BusinessLogicDo(bc.logicResChan)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 等待业务执行结果</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-bc.logicResChan:</span><br><span class="line">		<span class="comment">// 业务执行结果</span></span><br><span class="line">		fmt.Println(runFuncName(), <span class="string">"bc.BusinessLogicDo wait.done..."</span>)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="comment">// 超时等待</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.TimeoutCtx.Done():</span><br><span class="line">		<span class="comment">// 超时退出</span></span><br><span class="line">		fmt.Println(runFuncName(), <span class="string">"bc.BusinessLogicDo timeout..."</span>)</span><br><span class="line">		bc.Err = ErrConcurrencyComponentTimeout</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	err = currentConponent.ChildsDo(ctx)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CheckoutPageComponent 订单结算页面组件</span></span><br><span class="line"><span class="keyword">type</span> CheckoutPageComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseConcurrencyComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 当前组件业务逻辑代码填充处</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *CheckoutPageComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"订单结算页面组件..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddressComponent 地址组件</span></span><br><span class="line"><span class="keyword">type</span> AddressComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseConcurrencyComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 并发组件实际填充业务逻辑的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *AddressComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"地址组件..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取地址信息 ing..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟远程调用地址服务</span></span><br><span class="line">	http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line"></span><br><span class="line">	resChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 写入业务执行结果</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取地址信息 done..."</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PayMethodComponent 支付方式组件</span></span><br><span class="line"><span class="keyword">type</span> PayMethodComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseConcurrencyComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 并发组件实际填充业务逻辑的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *PayMethodComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"支付方式组件..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取支付方式 ing..."</span>)</span><br><span class="line">	<span class="comment">// 模拟远程调用地址服务 略</span></span><br><span class="line">	resChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取支付方式 done..."</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StoreComponent 店铺组件</span></span><br><span class="line"><span class="keyword">type</span> StoreComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 并发组件实际填充业务逻辑的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *StoreComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"店铺组件..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SkuComponent 商品组件</span></span><br><span class="line"><span class="keyword">type</span> SkuComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 并发组件实际填充业务逻辑的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *SkuComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"商品组件..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PromotionComponent 优惠信息组件</span></span><br><span class="line"><span class="keyword">type</span> PromotionComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 并发组件实际填充业务逻辑的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *PromotionComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"优惠信息组件..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExpressComponent 物流组件</span></span><br><span class="line"><span class="keyword">type</span> ExpressComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 并发组件实际填充业务逻辑的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *ExpressComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"物流组件..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AftersaleComponent 售后组件</span></span><br><span class="line"><span class="keyword">type</span> AftersaleComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 并发组件实际填充业务逻辑的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *AftersaleComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"售后组件..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InvoiceComponent 发票组件</span></span><br><span class="line"><span class="keyword">type</span> InvoiceComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseConcurrencyComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 并发组件实际填充业务逻辑的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *InvoiceComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"发票组件..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取发票信息 ing..."</span>)</span><br><span class="line">	<span class="comment">// 模拟远程调用地址服务 略</span></span><br><span class="line">	resChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 写入业务执行结果</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取发票信息 done..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CouponComponent 优惠券组件</span></span><br><span class="line"><span class="keyword">type</span> CouponComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseConcurrencyComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 并发组件实际填充业务逻辑的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *CouponComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"优惠券组件..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取最优优惠券 ing..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟远程调用优惠券服务</span></span><br><span class="line">	http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入业务执行结果</span></span><br><span class="line">	resChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取最优优惠券 done..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GiftCardComponent 礼品卡组件</span></span><br><span class="line"><span class="keyword">type</span> GiftCardComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseConcurrencyComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 并发组件实际填充业务逻辑的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *GiftCardComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"礼品卡组件..."</span>)</span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取礼品卡信息 ing..."</span>)</span><br><span class="line">	<span class="comment">// 模拟远程调用地址服务 略</span></span><br><span class="line">	resChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 写入业务执行结果</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"获取礼品卡信息 done..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderComponent 订单金额详细信息组件</span></span><br><span class="line"><span class="keyword">type</span> OrderComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 当前组件业务逻辑代码填充处</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *OrderComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前组件的业务逻辑写这</span></span><br><span class="line">	fmt.Println(runFuncName(), <span class="string">"订单金额详细信息组件..."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo 示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化订单结算页面 这个大组件</span></span><br><span class="line">	checkoutPage := &amp;CheckoutPageComponent&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂载子组件</span></span><br><span class="line">	storeComponent := &amp;StoreComponent&#123;&#125;</span><br><span class="line">	skuComponent := &amp;SkuComponent&#123;&#125;</span><br><span class="line">	skuComponent.Mount(</span><br><span class="line">		&amp;PromotionComponent&#123;&#125;,</span><br><span class="line">		&amp;AftersaleComponent&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line">	storeComponent.Mount(</span><br><span class="line">		skuComponent,</span><br><span class="line">		&amp;ExpressComponent&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---挂载组件---</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通组件</span></span><br><span class="line">	checkoutPage.Mount(</span><br><span class="line">		storeComponent,</span><br><span class="line">		&amp;OrderComponent&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// 并发组件</span></span><br><span class="line">	checkoutPage.MountConcurrency(</span><br><span class="line">		&amp;AddressComponent&#123;&#125;,</span><br><span class="line">		&amp;PayMethodComponent&#123;&#125;,</span><br><span class="line">		&amp;InvoiceComponent&#123;&#125;,</span><br><span class="line">		&amp;CouponComponent&#123;&#125;,</span><br><span class="line">		&amp;GiftCardComponent&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化业务上下文 并设置超时时间</span></span><br><span class="line">	ctx := GetContext(<span class="number">5</span> * time.Second)</span><br><span class="line">	<span class="keyword">defer</span> ctx.CancelFunc()</span><br><span class="line">	<span class="comment">// 开始构建页面组件数据</span></span><br><span class="line">	checkoutPage.ChildsDo(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU() - <span class="number">1</span>)</span><br><span class="line">	DemoConcurrency(</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取正在运行的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFuncName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	pc := <span class="built_in">make</span>([]<span class="keyword">uintptr</span>, <span class="number">1</span>)</span><br><span class="line">	runtime.Callers(<span class="number">2</span>, pc)</span><br><span class="line">	f := runtime.FuncForPC(pc[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> f.Name()</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Running] go run &quot;../easy-tips/go/patterns/composite/concurrency/composite-concurrency.go&quot;</span><br><span class="line">main.(*StoreComponent).BusinessLogicDo 店铺组件...</span><br><span class="line">main.(*SkuComponent).BusinessLogicDo 商品组件...</span><br><span class="line">main.(*PromotionComponent).BusinessLogicDo 优惠信息组件...</span><br><span class="line">main.(*AftersaleComponent).BusinessLogicDo 售后组件...</span><br><span class="line">main.(*ExpressComponent).BusinessLogicDo 物流组件...</span><br><span class="line">main.(*OrderComponent).BusinessLogicDo 订单金额详细信息组件...</span><br><span class="line">main.(*PayMethodComponent).BusinessLogicDo 支付方式组件...</span><br><span class="line">main.(*PayMethodComponent).BusinessLogicDo 获取支付方式 ing...</span><br><span class="line">main.(*InvoiceComponent).BusinessLogicDo 发票组件...</span><br><span class="line">main.(*InvoiceComponent).BusinessLogicDo 获取发票信息 ing...</span><br><span class="line">main.(*GiftCardComponent).BusinessLogicDo 礼品卡组件...</span><br><span class="line">main.(*GiftCardComponent).BusinessLogicDo 获取礼品卡信息 ing...</span><br><span class="line">main.(*CouponComponent).BusinessLogicDo 优惠券组件...</span><br><span class="line">main.(*CouponComponent).BusinessLogicDo 获取发票信息 ing...</span><br><span class="line">main.(*AddressComponent).BusinessLogicDo 地址组件...</span><br><span class="line">main.(*AddressComponent).BusinessLogicDo 获取地址信息 ing...</span><br><span class="line">main.(*InvoiceComponent).BusinessLogicDo 获取发票信息 done...</span><br><span class="line">main.(*BaseConcurrencyComponent).Do bc.BusinessLogicDo wait.done...</span><br><span class="line">main.(*BaseConcurrencyComponent).Do bc.BusinessLogicDo wait.done...</span><br><span class="line">main.(*PayMethodComponent).BusinessLogicDo 获取支付方式 done...</span><br><span class="line">main.(*AddressComponent).BusinessLogicDo 获取地址信息 done...</span><br><span class="line">main.(*BaseConcurrencyComponent).Do bc.BusinessLogicDo wait.done...</span><br><span class="line">main.(*CouponComponent).BusinessLogicDo 获取发票信息 done...</span><br><span class="line">main.(*BaseConcurrencyComponent).Do bc.BusinessLogicDo wait.done...</span><br><span class="line">main.(*GiftCardComponent).BusinessLogicDo 获取礼品卡信息 done...</span><br><span class="line">main.(*BaseConcurrencyComponent).Do bc.BusinessLogicDo wait.done...</span><br></pre></td></tr></table></figure>
<h4 id="「组合模式」和「并发组合模式」基准测试对比"><a href="#「组合模式」和「并发组合模式」基准测试对比" class="headerlink" title="「组合模式」和「并发组合模式」基准测试对比"></a>「组合模式」和「并发组合模式」基准测试对比</h4><p>基准测试代码：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> composite</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"easy-tips/go/patterns/composite/concurrency"</span></span><br><span class="line">	<span class="string">"easy-tips/go/patterns/composite/normal"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// go test -benchmem -run=^$ easy-tips/go/patterns/composite -bench . -v -count=1 --benchtime 20s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Normal</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.SetParallelism(runtime.NumCPU())</span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			normal.Demo()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Concurrency</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.SetParallelism(runtime.NumCPU())</span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			concurrency.Demo()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本地机器Benchmark对比测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(TIGERB) 🤔 ➜  composite git:(master) ✗ go test -benchmem -run=^$ easy-tips/go/patterns/composite -bench . -v -count=1 --benchtime 20s </span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: easy-tips/go/patterns/composite</span><br><span class="line">Benchmark_Normal-4                   376          56666895 ns/op           35339 B/op        286 allocs/op</span><br><span class="line">Benchmark_Concurrency-4              715          32669301 ns/op           36445 B/op        299 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      easy-tips/go/patterns/composite 68.835s</span><br></pre></td></tr></table></figure>
<p>从上面的基准测试结果可以看出来<code>Benchmark_Concurrency-4</code>平均每次的执行时间是<code>32669301 ns</code>是要优于<code>Benchmark_Normal</code>的<code>56666895 ns</code>。</p>
<h2 id="结语-4"><a href="#结语-4" class="headerlink" title="结语"></a>结语</h2><p>「并发组合模式」是一个由特定的设计模式结合Go语言天生的并发特性，通过适当封装形成的“新模式”。</p>
<h2 id="附录「并发组合模式」的基础代码模板与使用说明"><a href="#附录「并发组合模式」的基础代码模板与使用说明" class="headerlink" title="附录「并发组合模式」的基础代码模板与使用说明"></a>附录「并发组合模式」的基础代码模板与使用说明</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Go设计模式实战系列</span></span><br><span class="line"><span class="comment">//组合模式</span></span><br><span class="line"><span class="comment">//@auhtor TIGERB&lt;https://github.com/TIGERB&gt;</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//example:</span></span><br><span class="line"><span class="comment">// 创建一个根组件</span></span><br><span class="line"><span class="comment">// 如果子组件存在并发组件则父组件必须为并发组件</span></span><br><span class="line"><span class="comment">// type RootComponent struct &#123;</span></span><br><span class="line"><span class="comment">// 	BaseConcurrencyComponent</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func (bc *RootComponent) BusinessLogicDo(resChan chan interface&#123;&#125;) (err error) &#123;</span></span><br><span class="line"><span class="comment">// 	// do nothing</span></span><br><span class="line"><span class="comment">// 	return</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 创建一个并发组件</span></span><br><span class="line"><span class="comment">// type DemoConcurrenyComponent struct &#123;</span></span><br><span class="line"><span class="comment">// 	BaseConcurrencyComponent</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func (bc *DemoConcurrenyComponent) BusinessLogicDo(resChan chan interface&#123;&#125;) (err error) &#123;</span></span><br><span class="line"><span class="comment">// 	// 并发组件业务逻辑填充到这</span></span><br><span class="line"><span class="comment">// 	return</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 创建一个普通组件</span></span><br><span class="line"><span class="comment">// type DemoComponent struct &#123;</span></span><br><span class="line"><span class="comment">// 	BaseComponent</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func (bc *DemoComponent) BusinessLogicDo(resChan chan interface&#123;&#125;) (err error) &#123;</span></span><br><span class="line"><span class="comment">// 	// 普通组件业务逻辑填充到这</span></span><br><span class="line"><span class="comment">// 	return</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// // 普通组件</span></span><br><span class="line"><span class="comment">// root.Mount(</span></span><br><span class="line"><span class="comment">// 	&amp;DemoComponent&#123;&#125;,</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// // 并发组件</span></span><br><span class="line"><span class="comment">// root := &amp;RootComponent&#123;&#125;</span></span><br><span class="line"><span class="comment">// root.MountConcurrency(</span></span><br><span class="line"><span class="comment">// 	&amp;DemoConcurrenyComponent&#123;&#125;,</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// // 初始化业务上下文 并设置超时时间</span></span><br><span class="line"><span class="comment">// ctx := GetContext(5 * time.Second)</span></span><br><span class="line"><span class="comment">// defer ctx.CancelFunc()</span></span><br><span class="line"><span class="comment">// // 开始执行子组件</span></span><br><span class="line"><span class="comment">// root.ChildsDo(ctx)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// ErrConcurrencyComponentTimeout 并发组件业务超时</span></span><br><span class="line">	ErrConcurrencyComponentTimeout = errors.New(<span class="string">"Concurrency Component Timeout"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context 业务上下文</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// context.WithTimeout派生的子上下文</span></span><br><span class="line">	TimeoutCtx context.Context</span><br><span class="line">	<span class="comment">// 超时函数</span></span><br><span class="line">	context.CancelFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetContext 获取业务上下文实例</span></span><br><span class="line"><span class="comment">// d 超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetContext</span><span class="params">(d time.Duration)</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line">	c := &amp;Context&#123;&#125;</span><br><span class="line">	c.TimeoutCtx, c.CancelFunc = context.WithTimeout(context.Background(), d)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Component 组件接口</span></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 添加一个子组件</span></span><br><span class="line">	Mount(c Component, components ...Component) error</span><br><span class="line">	<span class="comment">// 移除一个子组件</span></span><br><span class="line">	Remove(c Component) error</span><br><span class="line">	<span class="comment">// 执行当前组件业务:`BusinessLogicDo`和执行子组件:`ChildsDo`</span></span><br><span class="line">	<span class="comment">// ctx 业务上下文</span></span><br><span class="line">	<span class="comment">// currentConponent 当前组件</span></span><br><span class="line">	<span class="comment">// wg 父组件的waitgroup对象</span></span><br><span class="line">	Do(ctx *Context, currentConponent Component, wg *sync.WaitGroup) error</span><br><span class="line">	<span class="comment">// 执行当前组件业务逻辑</span></span><br><span class="line">	<span class="comment">// resChan 回写当前组件业务执行结果的channel</span></span><br><span class="line">	BusinessLogicDo(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	ChildsDo(ctx *Context) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BaseComponent 基础组件</span></span><br><span class="line"><span class="comment">// 实现Add:添加一个子组件</span></span><br><span class="line"><span class="comment">// 实现Remove:移除一个子组件</span></span><br><span class="line"><span class="keyword">type</span> BaseComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 子组件列表</span></span><br><span class="line">	ChildComponents []Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mount 挂载一个子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">Mount</span><span class="params">(c Component, components ...Component)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents, c)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(components) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents, components...)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 移除一个子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">Remove</span><span class="params">(c Component)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(bc.ChildComponents) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> c == childComponent &#123;</span><br><span class="line">			fmt.Println(runFuncName(), <span class="string">"移除:"</span>, reflect.TypeOf(childComponent))</span><br><span class="line">			bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents[:k], bc.ChildComponents[k+<span class="number">1</span>:]...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行子组件</span></span><br><span class="line"><span class="comment">// ctx 业务上下文</span></span><br><span class="line"><span class="comment">// currentConponent 当前组件</span></span><br><span class="line"><span class="comment">// wg 父组件的waitgroup对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context, currentConponent Component, wg *sync.WaitGroup)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//执行当前组件业务代码</span></span><br><span class="line">	err = currentConponent.BusinessLogicDo(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	<span class="keyword">return</span> currentConponent.ChildsDo(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BusinessLogicDo 当前组件业务逻辑代码填充处</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">BusinessLogicDo</span><span class="params">(resChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// do nothing</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChildsDo 执行子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseComponent)</span> <span class="title">ChildsDo</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	<span class="keyword">for</span> _, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> err = childComponent.Do(ctx, childComponent, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BaseConcurrencyComponent 并发基础组件</span></span><br><span class="line"><span class="keyword">type</span> BaseConcurrencyComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 合成复用基础组件</span></span><br><span class="line">	BaseComponent</span><br><span class="line">	<span class="comment">// 当前组件是否有并发子组件</span></span><br><span class="line">	HasChildConcurrencyComponents <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 并发子组件列表</span></span><br><span class="line">	ChildConcurrencyComponents []Component</span><br><span class="line">	<span class="comment">// wg 对象</span></span><br><span class="line">	*sync.WaitGroup</span><br><span class="line">	<span class="comment">// 当前组件业务执行结果channel</span></span><br><span class="line">	logicResChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 当前组件执行过程中的错误信息</span></span><br><span class="line">	Err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 移除一个子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseConcurrencyComponent)</span> <span class="title">Remove</span><span class="params">(c Component)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(bc.ChildComponents) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> c == childComponent &#123;</span><br><span class="line">			fmt.Println(runFuncName(), <span class="string">"移除:"</span>, reflect.TypeOf(childComponent))</span><br><span class="line">			bc.ChildComponents = <span class="built_in">append</span>(bc.ChildComponents[:k], bc.ChildComponents[k+<span class="number">1</span>:]...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, childComponent := <span class="keyword">range</span> bc.ChildConcurrencyComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> c == childComponent &#123;</span><br><span class="line">			fmt.Println(runFuncName(), <span class="string">"移除:"</span>, reflect.TypeOf(childComponent))</span><br><span class="line">			bc.ChildConcurrencyComponents = <span class="built_in">append</span>(bc.ChildComponents[:k], bc.ChildComponents[k+<span class="number">1</span>:]...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MountConcurrency 挂载一个并发子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseConcurrencyComponent)</span> <span class="title">MountConcurrency</span><span class="params">(c Component, components ...Component)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	bc.HasChildConcurrencyComponents = <span class="literal">true</span></span><br><span class="line">	bc.ChildConcurrencyComponents = <span class="built_in">append</span>(bc.ChildConcurrencyComponents, c)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(components) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	bc.ChildConcurrencyComponents = <span class="built_in">append</span>(bc.ChildConcurrencyComponents, components...)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChildsDo 执行子组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseConcurrencyComponent)</span> <span class="title">ChildsDo</span><span class="params">(ctx *Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> bc.WaitGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">		bc.WaitGroup = &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行并发子组件</span></span><br><span class="line">	<span class="keyword">for</span> _, childComponent := <span class="keyword">range</span> bc.ChildConcurrencyComponents &#123;</span><br><span class="line">		bc.WaitGroup.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> childComponent.Do(ctx, childComponent, bc.WaitGroup)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	<span class="keyword">for</span> _, childComponent := <span class="keyword">range</span> bc.ChildComponents &#123;</span><br><span class="line">		<span class="keyword">if</span> err = childComponent.Do(ctx, childComponent, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> bc.HasChildConcurrencyComponents &#123;</span><br><span class="line">		<span class="comment">// 等待并发组件执行结果</span></span><br><span class="line">		bc.WaitGroup.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do 执行子组件</span></span><br><span class="line"><span class="comment">// ctx 业务上下文</span></span><br><span class="line"><span class="comment">// currentConponent 当前组件</span></span><br><span class="line"><span class="comment">// wg 父组件的waitgroup对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BaseConcurrencyComponent)</span> <span class="title">Do</span><span class="params">(ctx *Context, currentConponent Component, wg *sync.WaitGroup)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="comment">// 初始化并发子组件channel</span></span><br><span class="line">	<span class="keyword">if</span> bc.logicResChan == <span class="literal">nil</span> &#123;</span><br><span class="line">		bc.logicResChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> currentConponent.BusinessLogicDo(bc.logicResChan)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 等待业务执行结果</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-bc.logicResChan:</span><br><span class="line">		<span class="comment">// 业务执行结果</span></span><br><span class="line">		fmt.Println(runFuncName(), <span class="string">"bc.BusinessLogicDo wait.done..."</span>)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="comment">// 超时等待</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.TimeoutCtx.Done():</span><br><span class="line">		<span class="comment">// 超时退出</span></span><br><span class="line">		fmt.Println(runFuncName(), <span class="string">"bc.BusinessLogicDo timeout..."</span>)</span><br><span class="line">		bc.Err = ErrConcurrencyComponentTimeout</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行子组件</span></span><br><span class="line">	err = currentConponent.ChildsDo(ctx)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>

<!-- Comments -->
<div>
    


</div>



            </div>
        </div>

        <!-- Footer -->
<footer id="footer">
    <div class="inner">
        <section>
            <h2>About</h2>
            <div>
                新一代轻量级PHP框架「<a href='http://easy-php.tigerb.cn'>EasyPHP</a>」作者，「<a href='http://skrshop.tech/'>《电商设计手册 | SkrShop》</a>」作者，「<a href='http://tigerb.cn/go-patterns'>《Go设计模式实战》系列</a>」作者。拥有创业&上市公司电商开发经验，现于小米集团从事后端开发工作。
            </div>
        </section>
        <section>
            <h2>Follow</h2>
            <ul class="icons">
                
                    <li><a href="https://twitter.com/CODERCOOKER" class="icon style2 fa-twitter" target="_blank" ><span class="label">Twitter</span></a></li>
                
                
                
                    <li><a href="https://www.instagram.com/codercooker/" class="icon style2 fa-instagram" target="_blank" ><span class="label">Instagram</span></a></li>
                
                
                
                    <li><a href="https://github.com/TIGERB" class="icon style2 fa-github" target="_blank" ><span class="label">GitHub</span></a></li>
                
                
                
                
                
                    <li><a href="mailto:tigerbcode@gmail.com" class="icon style2 fa-envelope-o" target="_blank" ><span class="label">Email</span></a></li>
                
                
                    <li><a href="\atom.xml" class="icon style2 fa-rss" target="_blank" ><span class="label">RSS</span></a></li>
                
            </ul>
        </section>
        <ul class="copyright">
            <li>&copy; TIGERB.cn All right reserved. 津ICP备17006784号-2</li>
            <li><a href="https://juejin.im/user/5855e82d1b69e6006c9278b4" target="_blank">juejin</a></li>
            <li><a href="https://segmentfault.com/u/tigerb" target="_blank">Segmentfault</a></li>
            <li><a href="http://skrshop.tech/">电商设计手册 | SkrShop</a></li>
            <li><a href="https://dayutalk.cn/">大愚Talk</a></li>
        </ul>
    </div>
</footer>
    </div>

    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- skel -->
<script src="/js/skel.min.js"></script>

<!-- Custom Code -->
<script src="/js/util.js"></script>

<!--[if lte IE 8]>
<script src="/js/ie/respond.min.js"></script>
<![endif]-->

<!-- Custom Code -->
<script src="/js/main.js"></script>

<!-- Gallery -->
<script src="https://cdn.bootcss.com/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->


</body>

</html>